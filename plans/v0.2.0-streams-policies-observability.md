# v0.2.0: Streams, Policies & Observability

## Status
- **Phase**: Implementation In Progress
- **Started**: 2025-11-02
- **Last Updated**: 2025-11-02 (PolicyEngine Complete)
- **Target Release**: v0.2.0
- **Owner**: Phil Carbone
- **Current Test Count**: 201 tests passing (87 Observability + 41 Core + 33 Policies + 12 Sequencing + 8 Partitioning + 20 Execution)

## Progress Tracking

### Phase 1: Plan Documentation âœ…
- [x] Plan approved
- [x] Plan document created
- [ ] Infrastructure mapping table documented

### Phase 2: Core Abstractions (TDD) âœ…
- [x] PolicyContext interface and tests (21 tests passing)
- [x] PolicyDecisionTrail implementation and tests (tested via PolicyContext)
- [x] UUIDv7 migration for identity value objects (10 tests passing)
- [x] **Hop-Based Context Architecture Refactoring**
  - [x] SecurityContext value object with tests (10 tests)
  - [x] MessageHop updated with routing + security context (2 tests)
  - [x] MessageEnvelope refactored (removed Topic, StreamKey, PartitionIndex, SequenceNumber, UserId, TenantId)
  - [x] Helper methods for null coalescing (10 tests for GetCurrent* methods)
  - [x] Updated all existing tests for new architecture

### Phase 3: Sequence Provider (TDD) âœ…
- [x] ISequenceProvider interface
- [x] Contract tests for all providers (12 tests)
- [x] InMemorySequenceProvider implementation
- [x] Monotonicity and thread-safety tests

### Phase 4: Partition Router (TDD) âœ…
- [x] IPartitionRouter interface
- [x] Contract tests for all routers (8 tests)
- [x] HashPartitionRouter implementation
- [ ] RoundRobinPartitionRouter implementation (future)

### Phase 5: Execution Strategies (TDD) âœ…
- [x] IExecutionStrategy interface
- [x] SerialExecutor with ordering tests (10 tests)
- [x] ParallelExecutor with concurrency tests (10 tests)
- [x] Lifecycle tests (Start/Stop/Drain - in contract tests)
- [x] CancellationToken propagation tests (in contract tests)

### Phase 6: Policy Engine (TDD) âœ…
- [x] PolicyEngine implementation (33 tests)
- [x] PolicyConfiguration fluent API
- [x] Policy matching tests (single policy, first match, no match)
- [x] Context propagation tests (via PolicyContext)
- [x] Decision trail recording tests (matched and unmatched policies)

### Phase 7: Trace Store (TDD) ðŸ“‹
- [ ] ITraceStore interface
- [ ] InMemoryTraceStore implementation
- [ ] Trace storage and retrieval tests
- [ ] Correlation query tests
- [ ] Causal chain query tests

### Phase 8: Benchmarks ðŸ“‹
- [ ] Benchmark project setup
- [ ] Executor benchmarks
- [ ] Sequence provider benchmarks
- [ ] Partition router benchmarks
- [ ] Policy evaluation benchmarks
- [ ] Trace capture overhead benchmarks

### Phase 9: Documentation ðŸ“‹
- [ ] Infrastructure mapping guide
- [ ] VSCode extension data guide
- [ ] Time-travel debugging guide
- [ ] Policy authoring guide
- [ ] TDD workflow guide
- [ ] Caller info capture guide

### Phase 10: Documentation Site Updates ðŸ“‹
- [ ] Review implemented features against documentation site
- [ ] Create documentation update plan for whizbang-lib.github.io
- [ ] Document discrepancies between implementation and docs
- [ ] Identify new features that need documentation
- [ ] Plan API documentation updates (sequence providers, partition routers, executors)
- [ ] Plan observability documentation (hops, causation tracking, security context)
- [ ] Plan policy engine documentation
- [ ] Create GitHub issues for documentation site updates

---

## Executive Summary

Implement Policy Engine with **stream-based message routing** using **strict TDD for all components**. Includes pluggable partition routing, sequence providers, comprehensive observability with caller-info tracking, and complete test coverage for every interface and implementation.

---

## Core Principle: TDD for Everything

**RED â†’ GREEN â†’ REFACTOR** for every component:
- Policies: Tests first, then implementation
- Execution strategies: Tests first, then implementation
- Trace store: Tests first, then implementation
- Decision trails: Tests first, then implementation
- Sequence providers: Tests first, then implementation
- Partition routers: Tests first, then implementation

**No code without tests first.**

---

## Architecture Overview

### Three-Layer Hierarchy

```
TOPIC (Policy-Driven Routing)
  â†“ Policies determine which topic based on message context
STREAM (Primary Abstraction - Ordering + Execution)
  â†“ Stream key determines which stream (e.g., aggregate ID)
PARTITION (Implementation Detail - Physical Parallelism)
  â†“ Internal sharding for scale (e.g., stream has 3 partitions)
```

### Infrastructure Mapping Table

| Whizbang Concept | Kafka/EventHub | RabbitMQ | Service Bus | Event Store |
|------------------|----------------|----------|-------------|-------------|
| **Topic** | Topic | Exchange | Topic | $category-{name} |
| **Stream** | Partition key | Routing key | SessionId | Stream ID |
| **Partition** | Partition (0..N) | Queue (1 per route) | Subscription | Subscription |
| **Sequence** | Offset | Delivery tag | SequenceNumber | EventNumber |
| **Ordering** | Per partition | Per queue | Per session | Per stream |
| **Policy Context** | Message headers | Message properties | User properties | Event metadata |
| **Trace** | W3C headers | Headers exchange | Custom properties | Metadata |
| **Caller Info** | Custom header | Custom property | Custom property | Metadata field |

---

## Message Envelope with Caller Information

```csharp
public class MessageEnvelope<TMessage> {
    // Identity & Causality
    public MessageId MessageId { get; init; }
    public CorrelationId CorrelationId { get; init; }
    public CausationId CausationId { get; init; }
    public DateTimeOffset Timestamp { get; init; }

    // Actual message payload
    public TMessage Payload { get; init; }

    // Routing metadata
    public string Topic { get; init; }
    public string StreamKey { get; init; }
    public int? PartitionIndex { get; init; }
    public long? SequenceNumber { get; init; }

    // Policy decision trail (for debugging/time-travel)
    public PolicyDecisionTrail PolicyTrail { get; init; }

    // User context
    public string? UserId { get; init; }
    public string? TenantId { get; init; }

    // Custom metadata
    public IReadOnlyDictionary<string, object> Metadata { get; init; }
}
```

### MessageHop with Caller Information

```csharp
public record MessageHop {
    // Service/Machine identity
    public string ServiceName { get; init; }
    public string MachineName { get; init; }
    public DateTimeOffset Timestamp { get; init; }

    // Routing information
    public string Topic { get; init; }
    public string StreamKey { get; init; }
    public int? PartitionIndex { get; init; }
    public long? SequenceNumber { get; init; }
    public string ExecutionStrategy { get; init; }

    // Caller information (for VSCode extension - jump to line)
    public string? CallerMemberName { get; init; }
    public string? CallerFilePath { get; init; }
    public int? CallerLineNumber { get; init; }

    // Performance
    public TimeSpan Duration { get; init; }
}
```

### Caller Information Capture

Use C# magic attributes to automatically capture call site:

```csharp
public static class MessageTracing {
    public static MessageHop RecordHop(
        string topic,
        string streamKey,
        string executionStrategy,
        [CallerMemberName] string? callerMemberName = null,
        [CallerFilePath] string? callerFilePath = null,
        [CallerLineNumber] int? callerLineNumber = null
    ) {
        return new MessageHop {
            ServiceName = Assembly.GetEntryAssembly()?.GetName().Name ?? "Unknown",
            MachineName = Environment.MachineName,
            Timestamp = DateTimeOffset.UtcNow,
            Topic = topic,
            StreamKey = streamKey,
            ExecutionStrategy = executionStrategy,
            CallerMemberName = callerMemberName,
            CallerFilePath = callerFilePath,
            CallerLineNumber = callerLineNumber
        };
    }
}

// Usage (automatic call site capture):
public class SerialExecutor : IExecutionStrategy {
    public async Task<TResult> ExecuteAsync<TResult>(...) {
        // Automatically captures: method="ExecuteAsync", file="SerialExecutor.cs", line=45
        var hop = MessageTracing.RecordHop(
            envelope.Topic,
            envelope.StreamKey,
            this.Name
        );

        envelope.PolicyTrail.AddHop(hop);

        // ... execute handler
    }
}
```

---

## Policy Context (Universal Context)

Flows through entire execution pipeline, accessible to internal code and user code:

```csharp
public class PolicyContext {
    // Message information
    public IMessage Message { get; init; }
    public Type MessageType { get; init; }
    public MessageEnvelope Envelope { get; init; }

    // Runtime context
    public string Environment { get; init; }
    public DateTimeOffset ExecutionTime { get; init; }
    public IServiceProvider Services { get; init; }

    // Policy evaluation state
    public PolicyDecisionTrail Trail { get; }  // Mutable - records decisions

    // User helpers (for policy expressions)
    public bool MatchesAggregate<T>() { }
    public bool HasTag(string tag) { }
    public bool HasFlag(WhizbangFlags flag) { }

    // Context enrichment (for user receptors)
    public T GetService<T>() { }
    public object? GetMetadata(string key) { }
}
```

---

## Policy Decision Trail (Debugging/Time-Travel)

Records every policy decision for observability:

```csharp
public class PolicyDecisionTrail {
    public List<PolicyDecision> Decisions { get; } = new();

    public void RecordDecision(
        string policyName,
        string rule,
        bool matched,
        object? configuration,
        string reason
    ) {
        Decisions.Add(new PolicyDecision {
            PolicyName = policyName,
            Rule = rule,
            Matched = matched,
            Configuration = configuration,
            Reason = reason,
            Timestamp = DateTimeOffset.UtcNow
        });
    }
}

public record PolicyDecision {
    public string PolicyName { get; init; }
    public string Rule { get; init; }
    public bool Matched { get; init; }
    public object? Configuration { get; init; }
    public string Reason { get; init; }
    public DateTimeOffset Timestamp { get; init; }
}
```

---

## Pluggable Abstractions

### 1. Partition Router Interface

```csharp
public interface IPartitionRouter {
    /// <summary>
    /// Determines which partition (0 to partitionCount-1) for a given stream key
    /// </summary>
    int SelectPartition(string streamKey, int partitionCount, PolicyContext context);
}
```

**Implementations:**
- `HashPartitionRouter` - Consistent hashing (default)
- `RoundRobinPartitionRouter` - Load balancing
- `RangePartitionRouter` - Key ranges (future)
- `CustomPartitionRouter` - User-defined logic (future)

### 2. Sequence Provider Interface

```csharp
public interface ISequenceProvider {
    /// <summary>
    /// Gets next sequence number for a stream
    /// Must be monotonically increasing and thread-safe
    /// </summary>
    Task<long> GetNextAsync(string streamKey, CancellationToken ct = default);

    /// <summary>
    /// Gets current sequence for a stream (without incrementing)
    /// </summary>
    Task<long> GetCurrentAsync(string streamKey, CancellationToken ct = default);

    /// <summary>
    /// Resets sequence for a stream (dangerous - for testing/admin only)
    /// </summary>
    Task ResetAsync(string streamKey, long newValue = 0, CancellationToken ct = default);
}
```

**Implementations:**
- `InMemorySequenceProvider` - ConcurrentDictionary + Interlocked (v0.2.0)
- `SqlSequenceProvider` - Database sequence/identity (v0.3.0)
- `RedisSequenceProvider` - INCR command (v0.4.0)
- `HybridLogicalClockProvider` - Physical + logical time (v0.4.0)

### 3. Execution Strategy Interface

```csharp
public interface IExecutionStrategy {
    string Name { get; }

    Task<TResult> ExecuteAsync<TResult>(
        MessageEnvelope<IMessage> envelope,
        Func<MessageEnvelope<IMessage>, PolicyContext, Task<TResult>> handler,
        PolicyContext context,
        CancellationToken ct
    );

    Task StartAsync(CancellationToken ct);
    Task StopAsync(CancellationToken ct);
    Task DrainAsync(CancellationToken ct);

    IObservable<ExecutionMetrics> Metrics { get; }
}
```

**Implementations:**
- `SerialExecutor` - Strict FIFO ordering (v0.2.0)
- `ParallelExecutor` - No ordering, concurrent execution (v0.2.0)
- `SequencedParallelExecutor` - Parallel execution with ordered commits (v0.3.0)

### 4. Trace Store Interface

```csharp
public interface ITraceStore {
    // Store complete message trace
    Task StoreAsync(MessageTrace trace, CancellationToken ct = default);

    // Query by message ID
    Task<MessageTrace?> GetByMessageIdAsync(MessageId messageId, CancellationToken ct = default);

    // Query by correlation (get all messages in workflow)
    Task<List<MessageTrace>> GetByCorrelationAsync(CorrelationId correlationId, CancellationToken ct = default);

    // Query by causation (get parent/child chain)
    Task<List<MessageTrace>> GetCausalChainAsync(MessageId messageId, CancellationToken ct = default);

    // Query by time range
    Task<List<MessageTrace>> GetByTimeRangeAsync(DateTimeOffset from, DateTimeOffset to, CancellationToken ct = default);

    // Get policy decisions for a message
    Task<List<PolicyDecisionTrail>> GetPolicyTrailAsync(MessageId messageId, CancellationToken ct = default);
}
```

**Implementations:**
- `InMemoryTraceStore` - v0.2.0 (testing)
- `SqlTraceStore` - v0.3.0 (persistent)
- `ElasticsearchTraceStore` - v0.4.0 (production observability)

---

## Policy-Driven Configuration

Policies drive **everything** - routing, execution, sequencing, partitioning:

```csharp
policies.When(ctx => ctx.MatchesAggregate<Order>())
        .Then(config => config
            // Topic & Stream
            .UseTopic("orders")
            .UseStream(ctx => $"order-{ctx.GetAggregateId()}")

            // Execution
            .UseStrategy<SerialExecutor>()
            .WithConcurrency(1)

            // Partitioning
            .WithPartitions(4)
            .UsePartitionRouter<HashPartitionRouter>()

            // Sequencing
            .UseSequenceProvider<InMemorySequenceProvider>()

            // Concurrency Control
            .UseBulkhead("order-processing", maxConcurrency: 10, maxQueue: 50)

            // Timeouts
            .UseTimeout(TimeSpan.FromSeconds(30))
        );

policies.When(ctx => ctx.Message is IProjection)
        .Then(config => config
            .UseTopic("projections")
            .UseStream("projections-shared")
            .UseStrategy<ParallelExecutor>()
            .WithConcurrency(20)
            .WithPartitions(8)
            .UsePartitionRouter<RoundRobinPartitionRouter>()
        );
```

---

## TDD Implementation Phases

### Phase 1: Core Abstractions (Tests First)
1. Write PolicyContext tests â†’ Implement PolicyContext
2. Write PolicyDecisionTrail tests â†’ Implement PolicyDecisionTrail
3. Write MessageEnvelope tests â†’ Implement MessageEnvelope
4. Write MessageTracing tests â†’ Implement MessageTracing

### Phase 2: Sequence Provider (Tests First)
1. Write ISequenceProvider contract tests
2. Write InMemorySequenceProvider tests â†’ Implement
3. Write monotonicity tests â†’ Verify implementation

### Phase 3: Partition Router (Tests First)
1. Write IPartitionRouter contract tests
2. Write HashPartitionRouter tests â†’ Implement
3. Write RoundRobinPartitionRouter tests â†’ Implement

### Phase 4: Execution Strategies (Tests First)
1. Write SerialExecutor ordering tests â†’ Implement
2. Write ParallelExecutor concurrency tests â†’ Implement
3. Write lifecycle tests â†’ Implement Start/Stop/Drain

### Phase 5: Policy Engine (Tests First)
1. Write PolicyEngine tests â†’ Implement
2. Write PolicyBuilder tests â†’ Implement
3. Write end-to-end integration tests

### Phase 6: Trace Store (Tests First)
1. Write ITraceStore tests
2. Write InMemoryTraceStore tests â†’ Implement
3. Write query tests â†’ Verify all query methods

### Phase 7: Benchmarks
1. Setup benchmark project
2. Create executor benchmarks
3. Create sequence provider benchmarks
4. Create partition router benchmarks
5. Create policy evaluation benchmarks
6. Create trace capture overhead benchmarks

### Phase 8: Documentation
1. Infrastructure mapping guide
2. VSCode extension data guide
3. Time-travel debugging guide
4. Policy authoring guide
5. TDD workflow guide

---

## File Structure

### Tests (ALL written before implementation)

```
whizbang/tests/
â”œâ”€â”€ Whizbang.Policies.Tests/
â”‚   â”œâ”€â”€ PolicyContextTests.cs
â”‚   â”œâ”€â”€ PolicyDecisionTrailTests.cs
â”‚   â”œâ”€â”€ PolicyEngineTests.cs
â”‚   â””â”€â”€ PolicyBuilderTests.cs
â”‚
â”œâ”€â”€ Whizbang.Observability.Tests/
â”‚   â”œâ”€â”€ MessageTraceTests.cs
â”‚   â”œâ”€â”€ TraceStoreTests.cs
â”‚   â”œâ”€â”€ EnvelopeSerializationTests.cs
â”‚   â””â”€â”€ CallerInfoCaptureTests.cs
â”‚
â”œâ”€â”€ Whizbang.Sequencing.Tests/
â”‚   â”œâ”€â”€ SequenceProviderContractTests.cs
â”‚   â”œâ”€â”€ InMemorySequenceProviderTests.cs
â”‚   â””â”€â”€ MonotonicityTests.cs
â”‚
â”œâ”€â”€ Whizbang.Partitioning.Tests/
â”‚   â”œâ”€â”€ PartitionRouterContractTests.cs
â”‚   â”œâ”€â”€ HashPartitionRouterTests.cs
â”‚   â””â”€â”€ RoundRobinPartitionRouterTests.cs
â”‚
â”œâ”€â”€ Whizbang.Execution.Tests/
â”‚   â”œâ”€â”€ SerialExecutorOrderingTests.cs
â”‚   â”œâ”€â”€ ParallelExecutorTests.cs
â”‚   â”œâ”€â”€ LifecycleTests.cs
â”‚   â””â”€â”€ CancellationTests.cs
â”‚
â”œâ”€â”€ Whizbang.Streams.Tests/
â”‚   â”œâ”€â”€ StreamRegistryTests.cs
â”‚   â”œâ”€â”€ StreamRoutingTests.cs
â”‚   â””â”€â”€ StreamLifecycleTests.cs
â”‚
â””â”€â”€ Whizbang.Benchmarks/
    â”œâ”€â”€ ExecutorBenchmarks.cs
    â”œâ”€â”€ SequenceProviderBenchmarks.cs
    â”œâ”€â”€ PartitionRouterBenchmarks.cs
    â”œâ”€â”€ PolicyEvaluationBenchmarks.cs
    â””â”€â”€ TraceCaptureOverheadBenchmarks.cs
```

### Implementation (ALL written after tests)

```
whizbang/src/Whizbang.Core/
â”œâ”€â”€ Policies/
â”‚   â”œâ”€â”€ PolicyContext.cs
â”‚   â”œâ”€â”€ PolicyDecisionTrail.cs
â”‚   â”œâ”€â”€ PolicyEngine.cs
â”‚   â””â”€â”€ PolicyBuilder.cs
â”‚
â”œâ”€â”€ Observability/
â”‚   â”œâ”€â”€ MessageEnvelope.cs
â”‚   â”œâ”€â”€ MessageTrace.cs
â”‚   â”œâ”€â”€ MessageHop.cs
â”‚   â”œâ”€â”€ MessageTracing.cs
â”‚   â”œâ”€â”€ ITraceStore.cs
â”‚   â””â”€â”€ InMemoryTraceStore.cs
â”‚
â”œâ”€â”€ Sequencing/
â”‚   â”œâ”€â”€ ISequenceProvider.cs
â”‚   â””â”€â”€ InMemorySequenceProvider.cs
â”‚
â”œâ”€â”€ Partitioning/
â”‚   â”œâ”€â”€ IPartitionRouter.cs
â”‚   â”œâ”€â”€ HashPartitionRouter.cs
â”‚   â””â”€â”€ RoundRobinPartitionRouter.cs
â”‚
â”œâ”€â”€ Execution/
â”‚   â”œâ”€â”€ IExecutionStrategy.cs
â”‚   â”œâ”€â”€ SerialExecutor.cs
â”‚   â””â”€â”€ ParallelExecutor.cs
â”‚
â””â”€â”€ Streaming/
    â”œâ”€â”€ IStream.cs
    â”œâ”€â”€ InMemoryStream.cs
    â””â”€â”€ StreamRegistry.cs
```

---

## Success Criteria

### Test Coverage
- âœ… 100% coverage for all core abstractions
- âœ… Contract tests for all interfaces
- âœ… Integration tests for end-to-end flows
- âœ… All tests pass before ANY implementation is considered complete

### Functional (Verified by Tests)
- âœ… Sequence providers guarantee monotonicity under concurrency
- âœ… Serial executor preserves exact FIFO order (verified by sequence numbers)
- âœ… Policy context flows through entire pipeline
- âœ… Decision trails capture all policy decisions
- âœ… Caller information captured correctly (method, file, line)
- âœ… Message traces include complete hop chain with caller info

### Performance (Benchmarks)
- âœ… Caller info capture: <5Î¼s overhead
- âœ… Partition routing: <5Î¼s per message
- âœ… Sequence generation: <10Î¼s (in-memory)
- âœ… Policy evaluation: <10Î¼s per message
- âœ… Trace capture: <20Î¼s overhead

### Documentation
- âœ… Plan document in /plans folder
- âœ… Infrastructure mapping table
- âœ… VSCode extension data guide
- âœ… TDD workflow guide
- âœ… Caller info capture guide

---

## Design Decisions Log

### 2025-11-02: Initial Architecture Decisions

1. **Stream as Primary Abstraction** - Partition is implementation detail
   - **Rationale**: Aligns with Kafka/EventHub and Service Bus models
   - **Impact**: Simplifies API, users think in streams not partitions

2. **Policy-Driven Topic Routing** - No convention-based routing
   - **Rationale**: Maximum flexibility, supports complex scenarios
   - **Impact**: More configuration but explicit and debuggable

3. **Caller Info via Magic Attributes** - [CallerMemberName], [CallerFilePath], [CallerLineNumber]
   - **Rationale**: Zero overhead, automatic capture, enables VSCode extension
   - **Impact**: Every hop records exact call site for debugging

4. **TDD for All Components** - No exceptions
   - **Rationale**: Quality, documentation, design-by-contract
   - **Impact**: More upfront work but higher confidence

5. **Semaphores + Signals** - Not just semaphores alone
   - **Rationale**: Semaphores for "how many", signals for "when"
   - **Impact**: More complex but more powerful coordination

6. **Hop-Based Context Architecture** - All context lives on hops, envelope is identity + payload only
   - **Rationale**: Like network packets, each hop adds a layer with contextual metadata
   - **Decision**:
     - **Move to MessageHop**: Topic, StreamKey, PartitionIndex, SequenceNumber, SecurityContext, Metadata
     - **Remove from Envelope**: Topic, StreamKey, PartitionIndex, SequenceNumber, UserId, TenantId, Timestamp, Metadata
     - **Keep on Envelope**: MessageId, CorrelationId, CausationId (identity/lineage), Payload, Hops, PolicyTrail
     - **Enforce first hop**: Constructor requires initial hop (every message originates somewhere)
     - **Timestamp**: First hop's timestamp IS the message timestamp
     - Hops are additive-only (immutable once added)
     - Null coalescing: if field is null on current hop, use previous hop's value
     - Metadata stitching: later hops override earlier hops for same keys
   - **Impact**:
     - MessageEnvelope becomes pure identity + payload + hops (cleaner)
     - Full traceability of ALL context changes (routing, security, metadata, timestamps)
     - Policies can modify any context at each hop
     - Message doesn't grow unnecessarily (null inheritance)
     - More extensible for future context types
   - **Examples**:
     - Message starts in "orders" topic, policy routes to "inventory" â†’ new hop with Topic="inventory"
     - User context changes when crossing service boundary â†’ new hop with different SecurityContext
     - Sequence number is per-source event store â†’ each hop has its own SequenceNumber
     - Metadata enrichment: first hop sets `{"priority": 5}`, second hop adds `{"enriched": true}` â†’ combined metadata is both

---

## Open Questions

None currently - all architectural questions resolved in planning phase.

---

## References

### Related Documentation
- Concurrency Control Proposal (whizbang-lib.github.io)
- Sequence Leasing Architecture (whizbang-lib.github.io)
- Policy Pattern Guide (whizbang-lib.github.io)

### External References
- Kafka Partitioning: https://kafka.apache.org/documentation/#intro_topics
- Azure Service Bus Sessions: https://learn.microsoft.com/en-us/azure/service-bus-messaging/message-sessions
- W3C Trace Context: https://www.w3.org/TR/trace-context/
- Caller Info Attributes: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information

---

## Implementation Changelog

### 2025-11-02: PolicyEngine Implementation

**Rationale:**
Implement policy-based routing and configuration system. Policies match messages to routing/execution configurations, enabling flexible message processing without hardcoded logic. Decision trail recording provides full audit trail of policy evaluations.

**Files Created:**
- `src/Whizbang.Core/Policies/IPolicyEngine.cs` - Policy engine interface
- `src/Whizbang.Core/Policies/PolicyEngine.cs` - Default policy engine implementation
- `src/Whizbang.Core/Policies/PolicyConfiguration.cs` - Fluent configuration API
- `tests/Whizbang.Policies.Tests/PolicyEngineTests.cs` - 13 test methods covering policy matching, configuration, and decision trail recording

**Key Changes:**

1. **Policy Engine**:
   - Evaluates policies in order until first match
   - Returns `PolicyConfiguration` for matched policy
   - Returns `null` when no policies match
   - Records all policy evaluations in decision trail
   - Handles predicate exceptions gracefully

2. **PolicyConfiguration Fluent API**:
   - `UseTopic(string)` - Set topic for routing
   - `UseStreamKey(string)` - Set stream key for partitioning
   - `UseExecutionStrategy<T>()` - Set execution strategy type
   - `UsePartitionRouter<T>()` - Set partition router type
   - `UseSequenceProvider<T>()` - Set sequence provider type
   - `WithPartitions(int)` - Set partition count
   - `WithConcurrency(int)` - Set max concurrency

3. **Decision Trail Recording**:
   - Records matched policies with configuration
   - Records unmatched policies with reason
   - Records predicate evaluation failures
   - Full audit trail for debugging and visualization

**Test Results:**
```
âœ… Total: 201 tests passing (+12 from previous 189)
   - Whizbang.Policies.Tests: 33 passed (+12 new tests)
   - Whizbang.Core.Tests: 41 passed
   - Whizbang.Observability.Tests: 87 passed
   - Whizbang.Sequencing.Tests: 12 passed
   - Whizbang.Partitioning.Tests: 8 passed
   - Whizbang.Execution.Tests: 20 passed
```

**New Tests Added:**
1. `PolicyEngine_ShouldMatchSinglePolicyAsync` - Single policy match
2. `PolicyEngine_ShouldMatchFirstMatchingPolicyAsync` - First match wins
3. `PolicyEngine_ShouldReturnNullWhenNoPolicyMatchesAsync` - No match returns null
4. `PolicyEngine_ShouldRecordDecisionInTrailAsync` - Matched decision recorded
5. `PolicyEngine_ShouldRecordUnmatchedPoliciesInTrailAsync` - Unmatched decisions recorded
6. `PolicyConfiguration_ShouldSupportTopicAsync` - Topic configuration
7. `PolicyConfiguration_ShouldSupportStreamKeyAsync` - Stream key configuration
8. `PolicyConfiguration_ShouldSupportExecutionStrategyAsync` - Execution strategy type
9. `PolicyConfiguration_ShouldSupportPartitionRouterAsync` - Partition router type
10. `PolicyConfiguration_ShouldSupportSequenceProviderAsync` - Sequence provider type
11. `PolicyConfiguration_ShouldSupportPartitionCountAsync` - Partition count
12. `PolicyConfiguration_ShouldSupportConcurrencyAsync` - Max concurrency
13. (Plus 20 additional PolicyContext tests from earlier phases)

**Technical Notes:**
- **Namespace Collision Resolution**: Initial compilation failed with error `CS0117: 'MessageEnvelope<TMessage>' does not contain a definition for 'Hops'`. The error message showed `Whizbang.Policies.Tests.MessageEnvelope<TMessage>` instead of `Whizbang.Core.Observability.MessageEnvelope<TMessage>`, indicating a namespace collision. Fixed by using fully-qualified type name: `Whizbang.Core.Observability.MessageEnvelope<TMessage>` in the test helper method `CreateTestEnvelope<TMessage>()` (PolicyEngineTests.cs:29).

**TDD Approach:**
- Tests written first for policy matching and configuration (RED phase)
- PolicyEngine and PolicyConfiguration implementation (GREEN phase)
- All 201 tests passing, code formatted with `dotnet format` (REFACTOR phase)

---

### 2025-11-02: Causation Hops - Distributed Tracing

**Rationale:**
Enable distributed tracing by carrying forward causation/parent message hops. This allows each message to carry a complete causal chain showing what led to its creation. Addresses the Dispatcher/Receptor flow where messages spawn new messages - the new messages can include the processing history of their parent.

**Files Created:**
- None (enum added to existing MessageHop.cs)

**Files Modified:**
- `src/Whizbang.Core/Observability/MessageHop.cs` - Added HopType enum, Type field, CausationMessageId, CausationMessageType
- `src/Whizbang.Core/Observability/MessageEnvelope.cs` - Updated all helper methods to filter by HopType.Current, added GetCausationHops() and GetCurrentHops()
- `tests/Whizbang.Observability.Tests/MessageTracingTests.cs` - Added 14 new tests

**Key Changes:**

1. **HopType Enum**:
   - `Current` (default) - Hop for the current message
   - `Causation` - Hop carried forward from parent/causation message

2. **MessageHop Additions**:
   - `Type` - Defaults to HopType.Current
   - `CausationMessageId` - MessageId of parent message (for Causation hops)
   - `CausationMessageType` - Type name of parent message (for debugging)

3. **Filtering in Helper Methods**:
   - All `GetCurrent*()` methods now filter to `HopType.Current` only
   - Causation hops are ignored when getting current state
   - This ensures parent message context doesn't interfere with current message processing

4. **New Helper Methods**:
   - `GetCausationHops()` - Returns all causation hops (parent message journey)
   - `GetCurrentHops()` - Returns all current message hops

5. **Dispatcher/Receptor Flow**:
   - Dispatcher creates hop for current message (HopType.Current)
   - Receptor receives message, creates ingress hop (HopType.Current)
   - Receptor creates outgoing messages, adds egress hop (HopType.Current)
   - Outgoing messages get parent's Current hops copied as Causation hops
   - This preserves full causal chain across message boundaries

6. **Benefits**:
   - Complete distributed tracing without external storage
   - Can see entire causal history in any message
   - Debugging becomes trivial: "what led to this message?"
   - VSCode extension can visualize full causal graph
   - Space efficient (only causation metadata, not full payloads)

**Test Results:**
```
âœ… Total: 134 tests passing (+14 from previous 120)
   - Whizbang.Policies.Tests: 21 passed
   - Whizbang.Core.Tests: 41 passed
   - Whizbang.Observability.Tests: 72 passed (+14 new tests)
```

**New Tests Added:**
1. `MessageHop_Type_DefaultsToCurrent` - Default hop type
2. `MessageHop_Type_CanBeSetToCausation` - Causation hop with fields
3. `MessageHop_CausationFields_AreNullForCurrentHops` - Null causation fields for Current hops
4. `MessageEnvelope_GetCausationHops_ReturnsEmpty_WhenNoCausationHops` - Empty case
5. `MessageEnvelope_GetCausationHops_ReturnsOnlyCausationHops` - Filter causation hops
6. `MessageEnvelope_GetCurrentHops_ReturnsOnlyCurrentHops` - Filter current hops
7. `MessageEnvelope_GetCurrentTopic_IgnoresCausationHops` - Topic filtering
8. `MessageEnvelope_GetCurrentStreamKey_IgnoresCausationHops` - Stream key filtering
9. `MessageEnvelope_GetCurrentPartitionIndex_IgnoresCausationHops` - Partition filtering
10. `MessageEnvelope_GetCurrentSequenceNumber_IgnoresCausationHops` - Sequence filtering
11. `MessageEnvelope_GetCurrentSecurityContext_IgnoresCausationHops` - Security context filtering
12. `MessageEnvelope_GetMetadata_IgnoresCausationHops` - Metadata key filtering
13. `MessageEnvelope_GetAllMetadata_IgnoresCausationHops` - All metadata filtering
14. `MessageEnvelope_GetAllPolicyDecisions_IgnoresCausationHops` - Policy decision filtering

**TDD Approach:**
- Tests written first for HopType and causation fields (RED phase)
- Implementation updated with enum, fields, and filtering (GREEN phase)
- All existing tests still passing, code formatted with `dotnet format` (REFACTOR phase)

---

### 2025-11-02: Hop-Based Policy Trail - Complete Observability

**Rationale:**
Final step in hop-based architecture - move PolicyDecisionTrail from MessageEnvelope to MessageHop. Each hop can now record the policy decisions made at that point in the message journey. This enables complete chronological traceability of all policy evaluations throughout message processing.

**Files Modified:**
- `src/Whizbang.Core/Observability/MessageHop.cs` - Added PolicyDecisionTrail? Trail field
- `src/Whizbang.Core/Observability/MessageEnvelope.cs` - Removed PolicyTrail field, added GetAllPolicyDecisions() helper
- `tests/Whizbang.Observability.Tests/MessageTracingTests.cs` - Updated test, added 6 new tests

**Key Changes:**

1. **MessageHop Now Contains Policy Trail**:
   - Each hop can have its own PolicyDecisionTrail
   - Records policy decisions made at that specific hop
   - Nullable (not all hops involve policy evaluation)

2. **MessageEnvelope Becomes Pure Identity + Journey**:
   - MessageId, CorrelationId, CausationId (identity/lineage)
   - Payload (the message)
   - Hops (required, at least one, contains ALL context)
   - No more PolicyTrail field

3. **Policy Decision Stitching**:
   - `GetAllPolicyDecisions()` - Stitches decisions from all hops in chronological order
   - Maintains full audit trail of policy evaluations
   - Preserves temporal ordering (first hop to last hop)

4. **Architecture Completeness**:
   - 100% pure hop-based architecture achieved
   - ALL contextual information now lives on hops:
     - Routing: Topic, StreamKey, PartitionIndex, SequenceNumber
     - Security: SecurityContext (UserId, TenantId)
     - Metadata: Custom key/value pairs with stitching
     - Policy: PolicyDecisionTrail with chronological stitching
     - Timing: Timestamp, Duration
     - Debugging: CallerMemberName, CallerFilePath, CallerLineNumber
     - Execution: ServiceName, MachineName, ExecutionStrategy
   - MessageEnvelope is now purely: identity + payload + journey
   - Network packet analogy fully realized

5. **Benefits**:
   - Complete time-travel debugging capability
   - Full traceability of policy changes across hops
   - Each hop is a complete snapshot of processing state
   - VSCode extension can show policy evolution
   - Easier to understand "why did this happen?" questions

**Test Results:**
```
âœ… Total: 120 tests passing (+6 from previous 114)
   - Whizbang.Policies.Tests: 21 passed
   - Whizbang.Core.Tests: 41 passed
   - Whizbang.Observability.Tests: 58 passed (+6 new tests)
```

**New Tests Added:**
1. `MessageEnvelope_GetAllPolicyDecisions_ReturnsEmpty_WhenNoHopsHaveTrails` - Empty case
2. `MessageEnvelope_GetAllPolicyDecisions_ReturnsSingleHopDecisions` - Single hop with trail
3. `MessageEnvelope_GetAllPolicyDecisions_StitchesDecisionsAcrossMultipleHops` - Multi-hop stitching
4. `MessageEnvelope_GetAllPolicyDecisions_MaintainsChronologicalOrder` - Temporal ordering
5. `MessageEnvelope_GetAllPolicyDecisions_SkipsHopsWithoutTrails` - Null handling
6. `MessageHop_Trail_CanBeNull` - Trail can be null
7. `MessageHop_Trail_CanBeSet` - Trail can be set with decisions

**TDD Approach:**
- Tests written first for hop-based trail (RED phase)
- Implementation updated to use hop-based trail (GREEN phase)
- All existing tests passing, code formatted with `dotnet format` (REFACTOR phase)

---

### 2025-11-02: Pure Hop-Based Architecture - Complete Context Migration

**Rationale:**
Final iteration of hop-based architecture: moved ALL context to hops (including Timestamp and Metadata). Enforced first hop requirement - every message must originate somewhere. Envelope is now pure identity + payload + hops.

**Files Modified:**
- `src/Whizbang.Core/Observability/MessageHop.cs` - Added Metadata field
- `src/Whizbang.Core/Observability/MessageEnvelope.cs` - Removed Timestamp and Metadata, made Hops required, added helper methods

**Tests Added/Modified:**
- `tests/Whizbang.Observability.Tests/MessageTracingTests.cs` - Updated all envelope tests, added 5 new tests
  - `MessageEnvelope_RequiresAtLeastOneHop` - Tests first hop requirement
  - `MessageEnvelope_GetMessageTimestamp_ReturnsFirstHopTimestamp` - Timestamp from first hop
  - `MessageEnvelope_GetMetadata_ReturnsLatestValue_WhenKeyExistsInMultipleHops` - Null coalescing for metadata
  - `MessageEnvelope_GetAllMetadata_StitchesAllMetadata` - Metadata stitching with later hops overriding
  - `MessageEnvelope_GetAllMetadata_ReturnsEmpty_WhenNoHopsHaveMetadata` - Edge case testing

**Key Changes:**

1. **MessageHop.Metadata** (new field):
   - Each hop can carry its own metadata
   - Later hops override earlier hops for same keys (dictionary merge)
   - Nullable for space efficiency

2. **MessageEnvelope.Timestamp** (removed):
   - Timestamp is now `Hops[0].Timestamp` (first hop's timestamp)
   - Helper method: `GetMessageTimestamp()` returns first hop's timestamp
   - Cleaner: message timestamp IS the origination timestamp

3. **MessageEnvelope.Metadata** (removed):
   - Moved entirely to hops
   - Helper methods:
     - `GetMetadata(key)` - walks backwards, returns most recent value
     - `GetAllMetadata()` - stitches all hop metadata, later wins

4. **MessageEnvelope.Hops** (now required):
   - Changed from `List<MessageHop> Hops { get; init; } = new()` to `required List<MessageHop> Hops { get; init; }`
   - Every envelope MUST have at least one hop (origin)
   - Enforces "every message originates somewhere" principle

5. **Benefits**:
   - **Pure architecture**: Envelope is ONLY identity (MessageId, CorrelationId, CausationId) + payload + hops + policy trail
   - **Complete traceability**: ALL context changes tracked (routing, security, metadata, timing)
   - **Metadata enrichment**: Each hop can add/override metadata as message flows
   - **Space efficient**: Null coalescing prevents repeating unchanged values
   - **Consistent model**: Everything contextual is on hops

**Test Results:**
```
âœ… Total: 114 tests passing (+5 from previous 109)
   - Whizbang.Policies.Tests: 21 passed
   - Whizbang.Core.Tests: 41 passed
   - Whizbang.Observability.Tests: 52 passed (+5 new tests)
```

**TDD Approach:**
- Tests updated first for new required Hops field (RED phase)
- Implementation updated: removed Timestamp/Metadata, added helpers (GREEN phase)
- New tests added for GetMessageTimestamp(), GetMetadata(), GetAllMetadata()
- All tests passing, code formatted with `dotnet format` (REFACTOR phase)

---

### 2025-11-02: Hop-Based Context Architecture - Network Packet Inspired Design

**Rationale:**
Architectural refactoring based on network packet analogy - each hop adds a layer of contextual metadata. Routing and security context can change from hop to hop as messages cross service boundaries.

**Files Created:**
- `src/Whizbang.Core/Observability/SecurityContext.cs` - Security metadata (UserId, TenantId, extensible for future)

**Files Modified:**
- `src/Whizbang.Core/Observability/MessageHop.cs` - Added SecurityContext field
- `src/Whizbang.Core/Observability/MessageEnvelope.cs` - Removed duplicated fields, added helper methods
  - **Removed**: Topic, StreamKey, PartitionIndex, SequenceNumber, UserId, TenantId
  - **Added**: GetCurrentTopic(), GetCurrentStreamKey(), GetCurrentPartitionIndex(), GetCurrentSequenceNumber(), GetCurrentSecurityContext()

**Tests Added/Modified:**
- `tests/Whizbang.Observability.Tests/SecurityContextTests.cs` - 10 new tests
- `tests/Whizbang.Observability.Tests/MessageTracingTests.cs` - Updated existing tests, added 12 new tests
  - 2 tests for MessageHop SecurityContext
  - 10 tests for MessageEnvelope helper methods (null coalescing)

**Key Changes:**

1. **SecurityContext Value Object**:
   - Encapsulates UserId and TenantId
   - Extensible for future security needs (roles, claims, permissions)
   - Can be null (inherits from previous hop)

2. **MessageHop Now Contains Context**:
   - Topic, StreamKey, PartitionIndex, SequenceNumber (already existed)
   - SecurityContext (newly added)
   - All fields nullable for space efficiency

3. **MessageEnvelope Becomes Lighter**:
   - Only identity + payload + hops + metadata
   - No routing or security fields (moved to hops)
   - Cleaner separation of concerns

4. **Null Coalescing Pattern**:
   - Helper methods walk backwards through hops
   - Returns first non-null value found
   - Enables message size optimization (don't repeat unchanged values)
   - Examples:
     - `GetCurrentTopic()` - returns most recent non-empty topic
     - `GetCurrentSecurityContext()` - returns most recent non-null security context

5. **Benefits**:
   - Full traceability of routing and security changes
   - Policies can modify context at each hop
   - Message doesn't grow unnecessarily (null inheritance)
   - More extensible for future context types
   - Aligns with network packet layering model

**Test Results:**
```
âœ… Total: 109 tests passing (+22 from previous 87)
   - Whizbang.Policies.Tests: 21 passed
   - Whizbang.Core.Tests: 41 passed
   - Whizbang.Observability.Tests: 47 passed (+22 new tests)
```

**TDD Approach:**
- SecurityContext tests written first (RED phase)
- SecurityContext implementation (GREEN phase)
- MessageHop SecurityContext field added with tests
- MessageEnvelope refactored with tests for helper methods
- All existing tests updated for new architecture
- Code formatted with `dotnet format` (REFACTOR phase)

---

### 2025-11-02: UUIDv7 Migration - Database-Friendly Identity Values

**Files Modified:**
- `src/Whizbang.Core/ValueObjects/MessageId.cs` - Updated to use `Guid.CreateVersion7()`
- `src/Whizbang.Core/ValueObjects/CorrelationId.cs` - Updated to use `Guid.CreateVersion7()`
- `src/Whizbang.Core/ValueObjects/CausationId.cs` - Updated to use `Guid.CreateVersion7()`

**Tests Added:**
- `tests/Whizbang.Core.Tests/ValueObjects/IdentityValueObjectTests.cs` - 10 tests passing
  - 3 tests per ID type (uniqueness, time-ordering, sequential generation)
  - 1 cross-type consistency test

**Key Changes:**
1. **Database Performance** - Switched from random GUIDs (`Guid.NewGuid()`) to UUIDv7 (`Guid.CreateVersion7()`):
   - Eliminates ~90% index fragmentation
   - Sequential inserts reduce page splits
   - Improved cache locality
   - Better query performance

2. **Time-Ordered IDs** - UUIDv7 embeds timestamp in first 48 bits:
   - IDs are sortable by creation time
   - Natural chronological ordering
   - Useful for event sourcing scenarios

3. **Standard Compliance** - Uses RFC 9562 UUIDv7 standard:
   - .NET 9.0 native support
   - Zero breaking changes (still `Guid` type)
   - Industry standard format

**Test Coverage:**
- Tests verify uniqueness (all IDs different)
- Tests verify time-ordering (sortable by creation time)
- Tests verify sequential generation (100 IDs maintain order)
- Tests verify cross-type consistency

**Test Results:**
```
âœ… Total: 87 tests passing (+10 from previous 77)
   - Whizbang.Policies.Tests: 21 passed
   - Whizbang.Core.Tests: 41 passed (+10 identity tests)
   - Whizbang.Observability.Tests: 25 passed
```

**TDD Approach:**
- Tests written BEFORE implementation changes (RED phase)
- Implementation updated to make tests pass (GREEN phase)
- Code formatted with `dotnet format` (REFACTOR phase)

---

### 2025-11-02: Phase 2 Complete - Core Abstractions & Observability

**Files Created:**
- `src/Whizbang.Core/Policies/PolicyContext.cs` - Universal context for pipeline
- `src/Whizbang.Core/Policies/PolicyDecisionTrail.cs` - Policy decision recording
- `src/Whizbang.Core/Observability/MessageEnvelope.cs` - Message wrapper with metadata
- `src/Whizbang.Core/Observability/MessageHop.cs` - Hop recording with caller info
- `src/Whizbang.Core/Observability/MessageTracing.cs` - Helper with magic attributes
- `src/Whizbang.Core/Observability/MessageTrace.cs` - Complete message journey tracking

**Test Projects Created:**
- `tests/Whizbang.Policies.Tests/` - 21 tests passing
- `tests/Whizbang.Observability.Tests/` - 25 tests passing

**Key Features Implemented:**
1. **PolicyContext** - Universal context flowing through entire pipeline with:
   - Message and envelope access
   - Service provider integration
   - Metadata helpers (GetMetadata, HasTag, HasFlag)
   - Aggregate matching (MatchesAggregate, GetAggregateId)

2. **PolicyDecisionTrail** - Records all policy decisions with:
   - Decision tracking (policy name, rule, matched, configuration, reason)
   - Timestamp for each decision
   - Filtered queries (GetMatchedRules, GetUnmatchedRules)

3. **MessageEnvelope** - Wraps messages with:
   - Identity tracking (MessageId, CorrelationId, CausationId)
   - Routing metadata (Topic, StreamKey, PartitionIndex, SequenceNumber)
   - Policy trail and hops list
   - User/Tenant context
   - Custom metadata dictionary

4. **MessageHop** - Records each processing hop with:
   - Service and machine identity
   - Routing information
   - **Automatic caller information** ([CallerMemberName], [CallerFilePath], [CallerLineNumber])
   - Duration tracking

5. **MessageTracing** - Static helper with:
   - Zero-cost compile-time caller info capture
   - RecordHop method with automatic call site tracking

6. **MessageTrace** - Tracks complete journey with:
   - All hops and policy trails
   - Success/error outcome
   - Total duration and stage timings

**Test Results:**
```
âœ… Total: 77 tests passing
   - Whizbang.Policies.Tests: 21 passed
   - Whizbang.Core.Tests: 31 passed (existing)
   - Whizbang.Observability.Tests: 25 passed
```

**TDD Approach:**
- All tests written BEFORE implementation (RED phase)
- Implementation written to make tests pass (GREEN phase)
- Code formatted with `dotnet format` (REFACTOR phase)
- 100% of new code has test coverage

**Infrastructure:**
- Added both test projects to solution file
- All code formatted to project standards
- All tests passing after formatting

---

## Notes

- This plan will be updated as implementation progresses
- Decision log will track any architectural changes
- All test results and benchmark numbers will be added to this document
- VSCode extension is NOT part of v0.2.0 - we're just capturing the data it will need
