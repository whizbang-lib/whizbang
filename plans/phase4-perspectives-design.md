# Phase 4: ProductInventoryService Perspectives - Design Document

## Overview

This document outlines the design and implementation strategy for Phase 4 of the Product Catalog & Inventory System: implementing perspectives that materialize events into database tables for querying.

## Goals

1. Implement 2 perspectives that handle product catalog and inventory events
2. Use `PerspectiveSchemaGenerator` (from Phase 1) for automatic table creation
3. Achieve 100% code coverage through TDD (RED-GREEN-REFACTOR)
4. Ensure AOT compatibility (zero reflection)
5. Follow Dapper + Postgres pattern from existing perspectives

## Perspectives to Implement

### 1. ProductCatalogPerspective
- **Events Handled**:
  - `ProductCreatedEvent` - INSERT new product
  - `ProductUpdatedEvent` - UPDATE product details (partial updates)
  - `ProductDeletedEvent` - Soft delete (UPDATE deleted_at)
- **Table Schema**: Auto-generated by `PerspectiveSchemaGenerator`
- **File**: `ECommerce.InventoryWorker/Perspectives/ProductCatalogPerspective.cs`

### 2. InventoryLevelsPerspective
- **Events Handled**:
  - `InventoryRestockedEvent` - UPDATE quantity (add)
  - `InventoryReservedEvent` - UPDATE quantity (subtract)
  - `InventoryAdjustedEvent` - UPDATE quantity (adjust)
- **Table Schema**: Auto-generated by `PerspectiveSchemaGenerator`
- **File**: `ECommerce.InventoryWorker/Perspectives/InventoryLevelsPerspective.cs`

## Perspective Pattern

Based on the existing `InventoryPerspective` in BFF.API, all perspectives follow this pattern:

```csharp
using System.Data;
using Dapper;
using Whizbang.Core;
using Whizbang.Core.Data;

namespace ECommerce.InventoryWorker.Perspectives;

/// <summary>
/// Materializes [events] into [table_name] table
/// </summary>
public class [Name]Perspective : IPerspectiveOf<[EventType]> {
  private readonly IDbConnectionFactory _connectionFactory;
  private readonly ILogger<[Name]Perspective> _logger;

  public [Name]Perspective(
    IDbConnectionFactory connectionFactory,
    ILogger<[Name]Perspective> logger) {
    _connectionFactory = connectionFactory;
    _logger = logger;
  }

  public async Task Update([EventType] @event, CancellationToken cancellationToken = default) {
    try {
      using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);
      EnsureConnectionOpen(connection);

      // Execute SQL INSERT/UPDATE/DELETE
      await connection.ExecuteAsync(@"
        [SQL statement]",
        new { /* parameters from @event */ });

      _logger.LogInformation("...");
    } catch (Exception ex) {
      _logger.LogError(ex, "...");
      throw;
    }
  }

  private static void EnsureConnectionOpen(IDbConnection connection) {
    if (connection.State != ConnectionState.Open) {
      connection.Open();
    }
  }
}
```

## Table Schemas

### ProductCatalog Table
Auto-generated by `PerspectiveSchemaGenerator` based on perspective class attributes:

```sql
CREATE TABLE inventoryworker.product_catalog (
  product_id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  price DECIMAL(10,2) NOT NULL,
  image_url TEXT,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP,
  deleted_at TIMESTAMP
);
```

### InventoryLevels Table
Auto-generated by `PerspectiveSchemaGenerator`:

```sql
CREATE TABLE inventoryworker.inventory_levels (
  product_id TEXT PRIMARY KEY,
  quantity INTEGER NOT NULL DEFAULT 0,
  reserved INTEGER NOT NULL DEFAULT 0,
  available INTEGER GENERATED ALWAYS AS (quantity - reserved) STORED,
  last_updated TIMESTAMP NOT NULL
);
```

## Multiple Event Handlers

The `ProductCatalogPerspective` needs to handle 3 different event types. We'll use the pattern where the perspective implements multiple `IPerspectiveOf<T>` interfaces:

```csharp
public class ProductCatalogPerspective :
  IPerspectiveOf<ProductCreatedEvent>,
  IPerspectiveOf<ProductUpdatedEvent>,
  IPerspectiveOf<ProductDeletedEvent> {

  // Three Update methods, one for each event type
  public async Task Update(ProductCreatedEvent @event, CancellationToken ct = default) { ... }
  public async Task Update(ProductUpdatedEvent @event, CancellationToken ct = default) { ... }
  public async Task Update(ProductDeletedEvent @event, CancellationToken ct = default) { ... }
}
```

Similarly for `InventoryLevelsPerspective`:

```csharp
public class InventoryLevelsPerspective :
  IPerspectiveOf<InventoryRestockedEvent>,
  IPerspectiveOf<InventoryReservedEvent>,
  IPerspectiveOf<InventoryAdjustedEvent> {

  public async Task Update(InventoryRestockedEvent @event, CancellationToken ct = default) { ... }
  public async Task Update(InventoryReservedEvent @event, CancellationToken ct = default) { ... }
  public async Task Update(InventoryAdjustedEvent @event, CancellationToken ct = default) { ... }
}
```

## Test Strategy

### Test Project
- **Location**: `tests/ECommerce.InventoryWorker.Tests/Perspectives/`
- **Test Files**:
  - `ProductCatalogPerspectiveTests.cs`
  - `InventoryLevelsPerspectiveTests.cs`

### Test Categories

Each perspective test file will have tests for each event handler:

#### ProductCatalogPerspectiveTests (3 handlers × ~5 tests = ~15 tests)
1. **ProductCreatedEvent Handler**:
   - Inserts new product record
   - Maps all properties correctly
   - Handles null ImageUrl
   - Logs success
   - Handles errors

2. **ProductUpdatedEvent Handler**:
   - Updates existing product
   - Handles partial updates (null properties)
   - Updates updated_at timestamp
   - Logs success
   - Handles errors

3. **ProductDeletedEvent Handler**:
   - Soft deletes (sets deleted_at)
   - Doesn't hard delete
   - Logs success
   - Handles errors

#### InventoryLevelsPerspectiveTests (3 handlers × ~5 tests = ~15 tests)
1. **InventoryRestockedEvent Handler**:
   - Creates row if product doesn't exist
   - Updates quantity (adds)
   - Updates last_updated timestamp
   - Logs success
   - Handles errors

2. **InventoryReservedEvent Handler**:
   - Updates reserved count
   - Decreases available (computed column)
   - Updates last_updated timestamp
   - Logs success
   - Handles errors

3. **InventoryAdjustedEvent Handler**:
   - Updates quantity (positive/negative adjustments)
   - Updates last_updated timestamp
   - Logs success
   - Handles errors

### Mocking Strategy

We need to mock:
- `IDbConnectionFactory` - Returns a mock `IDbConnection`
- `IDbConnection` - Verifies SQL executed via Dapper
- `ILogger<T>` - Verifies logging

This is complex because Dapper uses extension methods. Options:
1. **Integration tests** with real Postgres (testcontainers)
2. **Use an in-memory SQLite database** for testing
3. **Mock IDbConnection** and verify ExecuteAsync calls

For TDD simplicity, we'll use **Option 3** with a test helper that tracks SQL calls.

## Implementation Strategy (TDD)

### Phase 1: RED - Write Failing Tests

1. Create test infrastructure (TestDbConnection, TestDbConnectionFactory)
2. Write tests for ProductCatalogPerspective (3 handlers × ~5 tests)
3. Write tests for InventoryLevelsPerspective (3 handlers × ~5 tests)
4. Tests will fail because perspectives don't exist yet

### Phase 2: GREEN - Implement Perspectives

1. Create ProductCatalogPerspective with 3 Update methods
2. Create InventoryLevelsPerspective with 3 Update methods
3. Implement SQL INSERT/UPDATE for each handler
4. Run tests - should pass

### Phase 3: REFACTOR - Quality & Formatting

1. Review code for quality
2. Apply `dotnet format`
3. Verify no regressions
4. Update plan document

## SQL Operations

### ProductCatalogPerspective

**ProductCreatedEvent**:
```sql
INSERT INTO inventoryworker.product_catalog (
  product_id, name, description, price, image_url, created_at
) VALUES (
  @ProductId, @Name, @Description, @Price, @ImageUrl, @CreatedAt
)
```

**ProductUpdatedEvent** (partial update):
```sql
UPDATE inventoryworker.product_catalog
SET
  name = COALESCE(@Name, name),
  description = COALESCE(@Description, description),
  price = COALESCE(@Price, price),
  image_url = COALESCE(@ImageUrl, image_url),
  updated_at = @UpdatedAt
WHERE product_id = @ProductId
```

**ProductDeletedEvent** (soft delete):
```sql
UPDATE inventoryworker.product_catalog
SET deleted_at = @DeletedAt
WHERE product_id = @ProductId
```

### InventoryLevelsPerspective

**InventoryRestockedEvent** (UPSERT):
```sql
INSERT INTO inventoryworker.inventory_levels (
  product_id, quantity, reserved, last_updated
) VALUES (
  @ProductId, @NewTotalQuantity, 0, @RestockedAt
)
ON CONFLICT (product_id) DO UPDATE
SET
  quantity = @NewTotalQuantity,
  last_updated = @RestockedAt
```

**InventoryReservedEvent**:
```sql
UPDATE inventoryworker.inventory_levels
SET
  reserved = reserved + @Quantity,
  last_updated = @ReservedAt
WHERE product_id = @ProductId
```

**InventoryAdjustedEvent**:
```sql
UPDATE inventoryworker.inventory_levels
SET
  quantity = @NewTotalQuantity,
  last_updated = @AdjustedAt
WHERE product_id = @ProductId
```

## Dependencies

Each perspective requires:
- `IDbConnectionFactory` - for creating database connections
- `ILogger<T>` - for logging

Both are injected via constructor.

## Success Criteria

- ✅ 2 perspectives implemented
- ✅ ~30 tests written and passing
- ✅ 100% code coverage
- ✅ Zero reflection (AOT compatible)
- ✅ Follows existing perspective pattern
- ✅ Uses Dapper for SQL execution
- ✅ Code formatted with `dotnet format`
- ✅ No build warnings or errors
- ✅ Plan document updated

## File Locations

```
ECommerce.InventoryWorker/
└── Perspectives/
    ├── OrderInventoryPerspective.cs (existing)
    ├── ProductCatalogPerspective.cs (new)
    └── InventoryLevelsPerspective.cs (new)

ECommerce.InventoryWorker.Tests/
└── Perspectives/
    ├── ProductCatalogPerspectiveTests.cs (new)
    └── InventoryLevelsPerspectiveTests.cs (new)
```

## Notes

- Tables are auto-created by `PerspectiveSchemaGenerator` at compile-time
- No manual schema.sql files needed
- Soft delete pattern for ProductDeletedEvent (set deleted_at, don't hard delete)
- UPSERT pattern for InventoryRestockedEvent (INSERT ... ON CONFLICT)
- Computed column `available = quantity - reserved` in inventory_levels
- All timestamps use `DateTime.UtcNow`
- Error handling: log and rethrow

---

## Implementation Summary

**Status**: ✅ **COMPLETE** (2025-11-17)

### Deliverables

1. **ProductCatalogPerspective** (`ECommerce.InventoryWorker/Perspectives/ProductCatalogPerspective.cs:1`)
   - Handles 3 events: ProductCreatedEvent, ProductUpdatedEvent, ProductDeletedEvent
   - Implements dynamic SQL building for partial updates (ProductUpdatedEvent:67)
   - Soft delete support via deleted_at timestamp
   - 11 integration tests with Testcontainers + PostgreSQL 17

2. **InventoryLevelsPerspective** (`ECommerce.InventoryWorker/Perspectives/InventoryLevelsPerspective.cs:1`)
   - Handles 3 events: InventoryRestockedEvent, InventoryReservedEvent, InventoryAdjustedEvent
   - UPSERT pattern for restocking with ON CONFLICT DO UPDATE (InventoryRestockedEvent:33)
   - Incremental reserved tracking for reservations
   - 14 integration tests with Testcontainers + PostgreSQL 17

3. **Test Infrastructure** (`ECommerce.InventoryWorker.Tests/TestHelpers/DatabaseTestHelper.cs:1`)
   - Testcontainers-based PostgreSQL 17 Alpine integration
   - Automatic schema initialization via PostgresSchemaInitializer
   - Test cleanup with TRUNCATE CASCADE
   - Reusable across all perspective tests

### Test Results

```
Test run summary: Passed!
  total: 61
  failed: 0
  succeeded: 61
  skipped: 0
  duration: 8s 254ms
```

**Test Coverage**:
- ProductCatalogPerspectiveTests: 11 tests
  - CREATE: 3 tests (insert, null handling, logging)
  - UPDATE: 6 tests (full update, partial update, null handling, timestamp tracking, logging)
  - DELETE: 2 tests (soft delete, no hard delete, logging)
- InventoryLevelsPerspectiveTests: 14 tests
  - RESTOCK: 5 tests (create, update, UPSERT, timestamp, logging)
  - RESERVE: 4 tests (decrement, accumulate, generated column, timestamp)
  - ADJUST: 5 tests (negative change, positive change, available column, timestamp, logging)

### Implementation Challenges & Solutions

1. **Dapper Column Mapping Issue**
   - **Problem**: PostgreSQL uses snake_case (product_id) but initial C# DTOs used PascalCase (ProductId)
   - **Solution**: Changed ProductRow and InventoryRow properties to snake_case to match database columns
   - **Files**: ProductCatalogPerspectiveTests.cs:398, InventoryLevelsPerspectiveTests.cs:458

2. **Partial Update with NULL Parameters**
   - **Problem**: COALESCE(@ImageUrl, image_url) doesn't work when @ImageUrl is explicitly NULL from .NET
   - **Solution**: Built dynamic SQL with List<string> for SET clauses - only add clauses for non-null fields
   - **File**: ProductCatalogPerspective.cs:67-103

3. **TUnit Attribute Updates**
   - **Problem**: Used non-existent `[AfterEach]` attribute
   - **Solution**: Changed to `[After(Test)]` following TUnit v0.88 patterns

4. **DateTime Value Type Assertions**
   - **Problem**: Can't use IsNotNull() on DateTime (value type)
   - **Solution**: Removed unnecessary assertions on non-nullable DateTime fields

### Code Quality

- ✅ All code formatted with `dotnet format`
- ✅ Zero reflection (AOT compatible)
- ✅ Follows existing perspective pattern from BFF.API
- ✅ Comprehensive XML documentation
- ✅ Proper error handling with logging

### Next Steps

Phase 4 is complete. Ready to proceed with Phase 5 or other development tasks.
