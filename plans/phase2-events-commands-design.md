# Phase 2: Events & Commands Design Document

**Created**: 2025-01-17
**Status**: Design Phase
**Phase**: 2/13 - Events & Commands (TDD)

---

## Overview

This phase focuses on creating the domain events and commands for the Product Catalog & Inventory System following strict TDD methodology. These contracts will be used by the ProductInventoryService receptors (Phase 3) and perspectives (Phase 4).

---

## Design Principles

1. **Records over Classes**: Use C# records for immutability
2. **Required Properties**: All essential properties marked as `required`
3. **Init-only**: All properties use `init` accessors
4. **Timestamps**: Include timestamp fields for audit trail
5. **Consistency**: Follow existing patterns in `InventoryReservedEvent` and `ReserveInventoryCommand`
6. **No Business Logic**: Pure data contracts only

---

## Product Catalog Events

### ProductCreatedEvent

**Purpose**: Published when a new product is added to the catalog

**Properties**:
- `ProductId` (string, required) - Unique product identifier
- `Name` (string, required) - Product name
- `Description` (string, required) - Product description
- `Price` (decimal, required) - Product price
- `ImageUrl` (string?, optional) - Product image URL
- `CreatedAt` (DateTime, required) - Timestamp of creation

**Aggregate**: Product
**Stream Key**: ProductId

### ProductUpdatedEvent

**Purpose**: Published when product details are updated

**Properties**:
- `ProductId` (string, required) - Product being updated
- `Name` (string?, optional) - Updated name (null if not changed)
- `Description` (string?, optional) - Updated description (null if not changed)
- `Price` (decimal?, optional) - Updated price (null if not changed)
- `ImageUrl` (string?, optional) - Updated image URL (null if not changed)
- `UpdatedAt` (DateTime, required) - Timestamp of update

**Aggregate**: Product
**Stream Key**: ProductId

**Design Note**: Using nullable properties to represent "no change" vs. explicit change

### ProductDeletedEvent

**Purpose**: Published when a product is soft-deleted from catalog

**Properties**:
- `ProductId` (string, required) - Product being deleted
- `DeletedAt` (DateTime, required) - Timestamp of deletion

**Aggregate**: Product
**Stream Key**: ProductId

---

## Inventory Management Events

### InventoryRestockedEvent

**Purpose**: Published when inventory is replenished

**Properties**:
- `ProductId` (string, required) - Product being restocked
- `QuantityAdded` (int, required) - Quantity added to inventory
- `NewTotalQuantity` (int, required) - Total quantity after restock
- `RestockedAt` (DateTime, required) - Timestamp of restock

**Aggregate**: Inventory
**Stream Key**: ProductId

### InventoryAdjustedEvent

**Purpose**: Published when inventory is manually adjusted (corrections, damages, etc.)

**Properties**:
- `ProductId` (string, required) - Product being adjusted
- `QuantityChange` (int, required) - Change in quantity (can be positive or negative)
- `NewTotalQuantity` (int, required) - Total quantity after adjustment
- `Reason` (string, required) - Reason for adjustment (e.g., "Damaged goods", "Inventory correction")
- `AdjustedAt` (DateTime, required) - Timestamp of adjustment

**Aggregate**: Inventory
**Stream Key**: ProductId

### InventoryReservedEvent

**Status**: ✅ Already exists
**Action**: Keep as-is, may enhance in Phase 3

---

## Product Catalog Commands

### CreateProductCommand

**Purpose**: Command to create a new product in the catalog

**Properties**:
- `ProductId` (string, required) - Unique product identifier (generated by client)
- `Name` (string, required) - Product name
- `Description` (string, required) - Product description
- `Price` (decimal, required) - Product price
- `ImageUrl` (string?, optional) - Product image URL
- `InitialStock` (int, required) - Initial inventory quantity

**Target**: ProductInventoryService
**Receptor**: CreateProductReceptor (Phase 3)
**Events**: ProductCreatedEvent + InventoryRestockedEvent (if InitialStock > 0)

### UpdateProductCommand

**Purpose**: Command to update product details

**Properties**:
- `ProductId` (string, required) - Product to update
- `Name` (string?, optional) - New name (null if not changing)
- `Description` (string?, optional) - New description (null if not changing)
- `Price` (decimal?, optional) - New price (null if not changing)
- `ImageUrl` (string?, optional) - New image URL (null if not changing)

**Target**: ProductInventoryService
**Receptor**: UpdateProductReceptor (Phase 3)
**Events**: ProductUpdatedEvent

### DeleteProductCommand

**Purpose**: Command to soft-delete a product from catalog

**Properties**:
- `ProductId` (string, required) - Product to delete

**Target**: ProductInventoryService
**Receptor**: DeleteProductReceptor (Phase 3)
**Events**: ProductDeletedEvent

---

## Inventory Management Commands

### RestockInventoryCommand

**Purpose**: Command to add inventory (restocking)

**Properties**:
- `ProductId` (string, required) - Product to restock
- `QuantityToAdd` (int, required) - Quantity being added

**Target**: ProductInventoryService
**Receptor**: RestockInventoryReceptor (Phase 3)
**Events**: InventoryRestockedEvent

**Validation**:
- QuantityToAdd must be > 0

### AdjustInventoryCommand

**Purpose**: Command to manually adjust inventory (corrections, damages)

**Properties**:
- `ProductId` (string, required) - Product to adjust
- `QuantityChange` (int, required) - Change in quantity (positive or negative)
- `Reason` (string, required) - Reason for adjustment

**Target**: ProductInventoryService
**Receptor**: AdjustInventoryReceptor (Phase 3)
**Events**: InventoryAdjustedEvent

**Validation**:
- Reason must not be null/empty

### ReserveInventoryCommand

**Status**: ✅ Already exists
**Action**: Keep as-is, may enhance receptor in Phase 3

---

## File Organization

```
samples/ECommerce/ECommerce.Contracts/
├── Commands/
│   ├── CreateProductCommand.cs          [NEW]
│   ├── UpdateProductCommand.cs          [NEW]
│   ├── DeleteProductCommand.cs          [NEW]
│   ├── RestockInventoryCommand.cs       [NEW]
│   ├── AdjustInventoryCommand.cs        [NEW]
│   └── ReserveInventoryCommand.cs       [EXISTING - KEEP]
└── Events/
    ├── ProductCreatedEvent.cs           [NEW]
    ├── ProductUpdatedEvent.cs           [NEW]
    ├── ProductDeletedEvent.cs           [NEW]
    ├── InventoryRestockedEvent.cs       [NEW]
    ├── InventoryAdjustedEvent.cs        [NEW]
    └── InventoryReservedEvent.cs        [EXISTING - KEEP]
```

---

## Test Strategy

### Test Project Structure

```
samples/ECommerce/ECommerce.Contracts.Tests/
├── ECommerce.Contracts.Tests.csproj
├── Events/
│   ├── ProductCreatedEventTests.cs
│   ├── ProductUpdatedEventTests.cs
│   ├── ProductDeletedEventTests.cs
│   ├── InventoryRestockedEventTests.cs
│   └── InventoryAdjustedEventTests.cs
└── Commands/
    ├── CreateProductCommandTests.cs
    ├── UpdateProductCommandTests.cs
    ├── DeleteProductCommandTests.cs
    ├── RestockInventoryCommandTests.cs
    └── AdjustInventoryCommandTests.cs
```

### Test Cases (Per Event/Command)

For each event/command, write tests for:

1. **Required Property Initialization**: Verify all required properties can be set
2. **Optional Property Initialization**: Verify optional properties can be null
3. **Init-Only Enforcement**: Verify properties cannot be modified after construction (implicit in records)
4. **IEvent/ICommand Interface**: Verify type implements correct interface
5. **Record Equality**: Verify two instances with same values are equal
6. **ToString Representation**: Verify readable string representation

**Example Test Structure**:
```csharp
[Test]
public async Task ProductCreatedEvent_WithValidProperties_InitializesSuccessfullyAsync() {
  // Arrange & Act
  var evt = new ProductCreatedEvent {
    ProductId = "prod-123",
    Name = "Widget",
    Description = "A quality widget",
    Price = 29.99m,
    ImageUrl = "https://example.com/widget.jpg",
    CreatedAt = DateTime.UtcNow
  };

  // Assert
  await Assert.That(evt.ProductId).IsEqualTo("prod-123");
  await Assert.That(evt.Name).IsEqualTo("Widget");
  await Assert.That(evt).IsAssignableFrom<IEvent>();
}
```

---

## TDD Workflow for Phase 2

### Step 1: Create Test Project
- Create `ECommerce.Contracts.Tests.csproj`
- Reference `ECommerce.Contracts`
- Reference `Whizbang.Core` (for IEvent/ICommand)
- Add TUnit packages

### Step 2: Write Tests (RED Phase)
- Create 10 test files (5 events, 5 commands)
- ~6 tests per file = ~60 tests total
- Run tests: EXPECT COMPILATION FAILURES (events/commands don't exist yet)

### Step 3: Implement (GREEN Phase)
- Create 5 event files
- Create 5 command files
- Run tests: ALL SHOULD PASS

### Step 4: Refactor
- Run `dotnet format`
- Ensure XML documentation on all types
- Verify consistency with existing patterns

### Step 5: Coverage & Regression
- Measure code coverage (should be 100%)
- Run full test suite: EXPECT NO REGRESSIONS
- Update baseline test count

---

## Acceptance Criteria

Phase 2 is complete when:

- ✅ ECommerce.Contracts.Tests project created
- ✅ 60 tests written (10 test files, ~6 tests each)
- ✅ All 60 tests passing
- ✅ 5 new event types created
- ✅ 5 new command types created
- ✅ 100% code coverage on new events/commands
- ✅ Zero test regressions in full suite
- ✅ `dotnet format` applied
- ✅ XML documentation on all public types

---

## Quality Gates

- [ ] **TDD**: All tests written before implementation
- [ ] **Coverage**: 100% line coverage on new code
- [ ] **Coverage**: 100% branch coverage on new code (N/A for records)
- [ ] **Regressions**: All existing tests pass
- [ ] **AOT**: Zero reflection (verified)
- [ ] **Format**: `dotnet format` executed
- [ ] **Docs**: XML comments on all public types

---

## Notes

### Why Records?

Records provide:
- Immutability by default
- Value-based equality
- Concise syntax
- Built-in ToString()
- Deconstruction support

### Why No Validation?

Events and commands are pure data contracts. Validation happens in:
- **Commands**: Validated by receptors before processing
- **Events**: Always valid (represent facts that already happened)

### Nullable Properties in UpdateProductCommand

Using nullable properties (e.g., `string? Name`) allows distinguishing between:
- `null` = "Don't change this field"
- Non-null = "Update to this value"

Alternative approaches rejected:
- ❌ Separate properties for "HasChanged" flags (verbose)
- ❌ Dictionary-based approach (loses type safety)
- ✅ Nullable properties (simple, type-safe)

---

## Change Log

### 2025-01-17
- Created design document
- Defined 5 new events
- Defined 5 new commands
- Established test strategy
- Documented TDD workflow
