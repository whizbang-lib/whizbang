extern alias shared;

using System.Diagnostics.CodeAnalysis;
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;
using TemplateUtilities = shared::Whizbang.Generators.Shared.Utilities.TemplateUtilities;

namespace Whizbang.Generators.Tests;

/// <summary>
/// Tests for TemplateUtilities - covers all utility methods for template manipulation.
/// Ensures 100% branch coverage for template loading, region replacement, and indentation.
/// </summary>
public class TemplateUtilitiesTests {
  // Use Generators assembly (where templates are embedded), not Shared assembly
  private static readonly System.Reflection.Assembly _generatorsAssembly = typeof(MessageRegistryGenerator).Assembly;

  [Test]
  public async Task ReplaceRegion_WithValidRegion_ReplacesContentAsync() {
    // Arrange
    var template = @"
namespace Test;

#region ROUTING
// Placeholder content
#endregion

public class Test { }";

    var replacement = "// Generated routing code\nif (true) { }";

    // Act
    var result = TemplateUtilities.ReplaceRegion(template, "ROUTING", replacement);

    // Assert
    await Assert.That(result).Contains("// Generated routing code");
    await Assert.That(result).DoesNotContain("Placeholder content");
  }

  [Test]
  public async Task ReplaceRegion_WithNonExistentRegion_ReturnsOriginalAsync() {
    // Arrange - Tests the match.Success == false branch
    var template = @"
namespace Test;

#region ROUTING
// Placeholder
#endregion";

    var replacement = "// Generated code";

    // Act
    var result = TemplateUtilities.ReplaceRegion(template, "NONEXISTENT", replacement);

    // Assert - Should return original template unchanged
    await Assert.That(result).IsEqualTo(template);
    await Assert.That(result).Contains("Placeholder");
  }

  [Test]
  public async Task ReplaceRegion_PreservesIndentationAsync() {
    // Arrange
    var template = @"
public class Test {
  #region METHODS
  // Placeholder
  #endregion
}";

    var replacement = "public void DoSomething() {\n  return;\n}";

    // Act
    var result = TemplateUtilities.ReplaceRegion(template, "METHODS", replacement);

    // Assert - Should preserve 2-space indentation
    await Assert.That(result).Contains("  public void DoSomething()");
    await Assert.That(result).Contains("    return;");
  }

  [Test]
  public async Task IndentCode_WithNullCode_ReturnsNullAsync() {
    // Arrange - Tests string.IsNullOrEmpty(code) branch
    string? code = null;

    // Act
    var result = TemplateUtilities.IndentCode(code!, "  ");

    // Assert
    await Assert.That(result).IsNull();
  }

  [Test]
  public async Task IndentCode_WithEmptyCode_ReturnsEmptyAsync() {
    // Arrange - Tests string.IsNullOrEmpty(code) branch
    var code = "";

    // Act
    var result = TemplateUtilities.IndentCode(code, "  ");

    // Assert
    await Assert.That(result).IsEqualTo("");
  }

  [Test]
  public async Task IndentCode_WithWhitespaceLine_PreservesItAsync() {
    // Arrange - Tests string.IsNullOrWhiteSpace(line) branch
    var code = "line1\n   \nline2";

    // Act
    var result = TemplateUtilities.IndentCode(code, "  ");

    // Assert - Whitespace-only line should not get indentation added
    await Assert.That(result).Contains("\n   \n");
  }

  [Test]
  public async Task IndentCode_WithNonEmptyLines_IndentsThemAsync() {
    // Arrange
    var code = "line1\nline2\nline3";

    // Act
    var result = TemplateUtilities.IndentCode(code, "  ");

    // Assert
    await Assert.That(result).IsEqualTo("  line1\n  line2\n  line3");
  }

  [Test]
  public async Task IndentCode_WithMixedLineEndings_HandlesAllTypesAsync() {
    // Arrange - Tests all line ending types: \r\n, \r, \n
    var code = "line1\r\nline2\rline3\nline4";

    // Act
    var result = TemplateUtilities.IndentCode(code, "  ");

    // Assert - All lines should be indented
    await Assert.That(result).Contains("  line1\n  line2\n  line3\n  line4");
  }

  [Test]
  [RequiresAssemblyFiles()]
  public async Task ExtractSnippet_WithNonExistentRegion_ReturnsErrorMessageAsync() {
    // Arrange - Tests match.Success == false branch in ExtractSnippet
    // Act
    var result = TemplateUtilities.ExtractSnippet(
        _generatorsAssembly,
        "DispatcherSnippets.cs",
        "NONEXISTENT_SNIPPET"
    );

    // Assert
    await Assert.That(result).Contains("ERROR");
    await Assert.That(result).Contains("NONEXISTENT_SNIPPET");
    await Assert.That(result).Contains("not found");
  }

  [Test]
  [RequiresAssemblyFiles()]
  public async Task ExtractSnippet_WithValidRegion_ExtractsContentAsync() {
    // Arrange
    // Act
    var result = TemplateUtilities.ExtractSnippet(
        _generatorsAssembly,
        "DispatcherSnippets.cs",
        "GENERATED_FILE_HEADER"
    );

    // Assert
    await Assert.That(result).IsNotNull();
    await Assert.That(result).Contains("// <auto-generated/>");
  }

  [Test]
  [RequiresAssemblyFiles()]
  public async Task GetEmbeddedTemplate_WithNonExistentResource_ReturnsErrorAsync() {
    // Arrange - Tests stream == null branch
    // Act
    var result = TemplateUtilities.GetEmbeddedTemplate(
        _generatorsAssembly,
        "NonExistentTemplate.cs"
    );

    // Assert
    await Assert.That(result).Contains("ERROR");
    await Assert.That(result).Contains("Template not found");
    await Assert.That(result).Contains("NonExistentTemplate.cs");
  }

  [Test]
  [RequiresAssemblyFiles()]
  public async Task GetEmbeddedTemplate_WithValidResource_ReturnsContentAsync() {
    // Arrange
    // Act
    var result = TemplateUtilities.GetEmbeddedTemplate(
        _generatorsAssembly,
        "DispatcherTemplate.cs"
    );

    // Assert
    await Assert.That(result).IsNotNull();
    await Assert.That(result).Contains("namespace");
  }

  [Test]
  [RequiresAssemblyFiles()]
  public async Task ReplaceHeaderRegion_ReplacesTimestampAsync() {
    // Arrange
    var template = @"
#region HEADER
// Old header
#endregion

namespace Test;";

    // Act
    var result = TemplateUtilities.ReplaceHeaderRegion(_generatorsAssembly, template);

    // Assert
    await Assert.That(result).Contains("// <auto-generated/>");
    await Assert.That(result).Contains("UTC");
    await Assert.That(result).DoesNotContain("Old header");
    await Assert.That(result).DoesNotContain("__TIMESTAMP__");
  }

  [Test]
  public async Task RemoveIndentation_WithNullCode_ReturnsNullAsync() {
    // Arrange - Tests string.IsNullOrEmpty(code) branch in RemoveIndentation
    string? code = null;

    // Act - Using reflection to call private method
    var method = typeof(TemplateUtilities).GetMethod(
        "_removeIndentation",
        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static
    );
    var result = method!.Invoke(null, [code, "  "]) as string;

    // Assert
    await Assert.That(result).IsNull();
  }

  [Test]
  public async Task RemoveIndentation_WithEmptyIndentation_ReturnsOriginalAsync() {
    // Arrange - Tests string.IsNullOrEmpty(indentationToRemove) branch
    var code = "  line1\n  line2";

    // Act - Using reflection to call private method
    var method = typeof(TemplateUtilities).GetMethod(
        "_removeIndentation",
        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static
    );
    var result = method!.Invoke(null, [code, ""]) as string;

    // Assert
    await Assert.That(result).IsEqualTo(code);
  }

  [Test]
  public async Task RemoveIndentation_WithWhitespaceLine_PreservesItAsync() {
    // Arrange - Tests string.IsNullOrWhiteSpace(line) branch in RemoveIndentation
    var code = "  line1\n   \n  line2";

    // Act - Using reflection to call private method
    var method = typeof(TemplateUtilities).GetMethod(
        "_removeIndentation",
        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static
    );
    var result = method!.Invoke(null, [code, "  "]) as string;

    // Assert
    await Assert.That(result).Contains("\n   \n");
  }

  [Test]
  public async Task RemoveIndentation_WithMatchingIndentation_RemovesItAsync() {
    // Arrange - Tests line.StartsWith(indentationToRemove) == true branch
    var code = "  line1\n  line2\n  line3";

    // Act - Using reflection to call private method
    var method = typeof(TemplateUtilities).GetMethod(
        "_removeIndentation",
        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static
    );
    var result = method!.Invoke(null, [code, "  "]) as string;

    // Assert
    await Assert.That(result).IsEqualTo("line1\nline2\nline3");
  }

  [Test]
  public async Task RemoveIndentation_WithNonMatchingIndentation_KeepsLineAsync() {
    // Arrange - Tests line.StartsWith(indentationToRemove) == false branch
    var code = "  line1\nline2\n  line3";

    // Act - Using reflection to call private method
    var method = typeof(TemplateUtilities).GetMethod(
        "_removeIndentation",
        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static
    );
    var result = method!.Invoke(null, [code, "  "]) as string;

    // Assert
    await Assert.That(result).Contains("\nline2\n");
  }
}
