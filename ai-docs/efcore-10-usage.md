# EF Core 10 Usage Standards

**Entity Framework Core 10 (.NET 10) - New Features and Patterns**

EF Core 10 is a Long Term Support (LTS) release (November 2025 - November 2028) with significant new features for PostgreSQL, including native JsonB support, UUIDv7, and complex types.

---

## Table of Contents

1. [Complex Types with JsonB](#complex-types-with-jsonb)
2. [UUIDv7 Support](#uuidv7-support)
3. [Partial JSON Updates](#partial-json-updates)
4. [Querying JSON Properties](#querying-json-properties)
5. [Virtual Generated Columns](#virtual-generated-columns)
6. [Array Mapping](#array-mapping)
7. [AOT Compatibility](#aot-compatibility)

---

## Complex Types with JsonB

### ✅ RECOMMENDED - EF Core 10 Complex Types (NEW)

As of EF Core 10, the **recommended** way to map .NET types to JSON is via **complex types**, where EF is fully aware of the structure and provides rich querying/updating capabilities.

```csharp
// Domain model
public class Order {
    public Guid Id { get; set; }
    public decimal TotalAmount { get; set; }

    // Complex types → JsonB columns in PostgreSQL
    public Address ShippingAddress { get; set; } = null!;
    public Address BillingAddress { get; set; } = null!;
    public PaymentInfo Payment { get; set; } = null!;
}

// Complex type (not an entity)
public class Address {
    public string Street { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
    public string State { get; set; } = string.Empty;
    public string PostalCode { get; set; } = string.Empty;
    public string Country { get; set; } = string.Empty;
}

public class PaymentInfo {
    public string Method { get; set; } = string.Empty;
    public string Last4Digits { get; set; } = string.Empty;
    public DateTime ExpirationDate { get; set; }
}
```

**Configuration:**

```csharp
public class OrderConfiguration : IEntityTypeConfiguration<Order> {
    public void Configure(EntityTypeBuilder<Order> builder) {
        builder.HasKey(o => o.Id);

        // Map complex types to JsonB columns
        builder.ComplexProperty(o => o.ShippingAddress, c => c.ToJson());
        builder.ComplexProperty(o => o.BillingAddress, c => c.ToJson());
        builder.ComplexProperty(o => o.Payment, c => c.ToJson());
    }
}
```

**Generated PostgreSQL Schema:**

```sql
CREATE TABLE "Orders" (
    "Id" uuid NOT NULL,
    "TotalAmount" numeric NOT NULL,
    "ShippingAddress" jsonb NOT NULL,  -- JsonB column
    "BillingAddress" jsonb NOT NULL,   -- JsonB column
    "Payment" jsonb NOT NULL,           -- JsonB column
    CONSTRAINT "PK_Orders" PRIMARY KEY ("Id")
);
```

---

### ❌ OLD APPROACH - Owned Entities (Pre-EF 10)

**Don't use this anymore!** Prior to EF 10, similar modeling was available via "owned entities", but this created several issues.

```csharp
// ❌ DON'T USE - Old approach
modelBuilder.Entity<Order>().OwnsOne(o => o.ShippingAddress, a => {
    a.ToJson();  // Old owned entity approach
});
```

If you see this pattern in existing code, refactor to complex types!

---

## UUIDv7 Support

### Time-Ordered GUIDs (Database-Friendly)

PostgreSQL 18 added the `uuidv7()` built-in function. When using EF Core 10 with PostgreSQL 18+, `Guid.CreateVersion7()` translates to the native `uuidv7()` function.

### ✅ CORRECT - Use UUIDv7 for all IDs

```csharp
public class Order {
    public Guid Id { get; set; }  // Will use uuidv7() in PostgreSQL 18+
}

// In code - create new entities
var order = new Order {
    Id = Guid.CreateVersion7(),  // Time-ordered, sequential
    // ...
};

await context.Orders.AddAsync(order);
await context.SaveChangesAsync();
```

**Benefits of UUIDv7:**
- ✅ Time-ordered (sortable by creation time)
- ✅ Database index-friendly (no fragmentation)
- ✅ Clustered index performance (inserts at end)
- ✅ Compatible with standard GUID/UUID
- ✅ Native PostgreSQL 18+ support

---

### ❌ WRONG - Guid.NewGuid() causes index fragmentation

```csharp
// ❌ DON'T USE - Random GUIDs
var order = new Order {
    Id = Guid.NewGuid(),  // Random, causes B-tree fragmentation
    // ...
};
```

**Problems with random GUIDs:**
- ❌ No time ordering
- ❌ Causes index fragmentation (random insertion points)
- ❌ Poor database performance (page splits)
- ❌ Inefficient for clustered indexes

---

### PostgreSQL Version Compatibility

**PostgreSQL 18+:**
```csharp
// Translates to native uuidv7() function
var id = Guid.CreateVersion7();
```

**PostgreSQL < 18:**
```csharp
// Still works! EF Core generates UUIDv7 client-side
var id = Guid.CreateVersion7();  // Generated by .NET, inserted as regular UUID
```

---

## Partial JSON Updates

EF Core 10 supports **partial updates** within JsonB documents using `ExecuteUpdateAsync`.

### ✅ Efficient - Update specific property

```csharp
// Update only the City property within ShippingAddress JsonB column
await context.Orders
    .Where(o => o.Id == orderId)
    .ExecuteUpdateAsync(s => s
        .SetProperty(o => o.ShippingAddress.City, "New York"));

// SQL Generated:
// UPDATE "Orders"
// SET "ShippingAddress" = jsonb_set("ShippingAddress", '{City}', '"New York"')
// WHERE "Id" = @orderId
```

### Multiple Property Updates

```csharp
// Update multiple properties within JsonB
await context.Orders
    .Where(o => o.CustomerId == customerId)
    .ExecuteUpdateAsync(s => s
        .SetProperty(o => o.ShippingAddress.City, "Seattle")
        .SetProperty(o => o.ShippingAddress.State, "WA")
        .SetProperty(o => o.ShippingAddress.PostalCode, "98101"));
```

### ❌ Inefficient - Replace entire document

```csharp
// ❌ Less efficient - replaces entire JsonB document
var order = await context.Orders.FindAsync(orderId);
order.ShippingAddress.City = "New York";
await context.SaveChangesAsync();

// Replaces entire ShippingAddress JsonB document
```

**When to use each:**
- **Partial update** (`ExecuteUpdateAsync`): Known single/few properties, no tracking needed
- **Full load** (`Find` + `SaveChanges`): Need entity tracking, complex logic, multiple changes

---

## Querying JSON Properties

EF Core 10 provides rich querying capabilities for JsonB columns.

### Filter by JSON Properties

```csharp
// Find orders shipping to Seattle
var seattleOrders = await context.Orders
    .Where(o => o.ShippingAddress.City == "Seattle")
    .ToListAsync();

// SQL Generated:
// SELECT ... FROM "Orders"
// WHERE "ShippingAddress"->>'City' = 'Seattle'
```

### Projection from JSON

```csharp
// Select specific JSON properties
var cities = await context.Orders
    .Select(o => new {
        OrderId = o.Id,
        ShippingCity = o.ShippingAddress.City,
        BillingCity = o.BillingAddress.City
    })
    .ToListAsync();
```

### Complex Queries

```csharp
// Combine JSON queries with other filters
var recentSeattleOrders = await context.Orders
    .Where(o =>
        o.CreatedAt > DateTime.UtcNow.AddDays(-30) &&
        o.ShippingAddress.City == "Seattle" &&
        o.Payment.Method == "CreditCard")
    .OrderByDescending(o => o.CreatedAt)
    .ToListAsync();
```

### JSON Containment Queries (PostgreSQL)

```csharp
// PostgreSQL JsonB containment operators
var orders = await context.Orders
    .Where(o => EF.Functions.JsonContains(
        o.ShippingAddress,
        new { City = "Seattle", State = "WA" }))
    .ToListAsync();
```

---

## Virtual Generated Columns

PostgreSQL 18+ supports **virtual generated columns** (computed columns that aren't stored).

### Default: Virtual Columns (PostgreSQL 18+)

```csharp
modelBuilder.Entity<Order>()
    .Property(o => o.TotalWithTax)
    .HasComputedColumnSql("\"TotalAmount\" * 1.08");  // Virtual by default in PG 18

// SQL Generated:
// "TotalWithTax" numeric GENERATED ALWAYS AS ("TotalAmount" * 1.08) VIRTUAL
```

### Stored Columns

```csharp
// Explicitly request stored column
modelBuilder.Entity<Order>()
    .Property(o => o.TotalWithTax)
    .HasComputedColumnSql("\"TotalAmount\" * 1.08", stored: true);

// SQL Generated:
// "TotalWithTax" numeric GENERATED ALWAYS AS ("TotalAmount" * 1.08) STORED
```

**Virtual vs Stored:**
- **Virtual**: Computed on-the-fly during queries, no storage cost
- **Stored**: Pre-computed and stored, can be indexed, uses storage

---

## Array Mapping

PostgreSQL has **first-class array types**, so EF Core maps collections to arrays (not JSON arrays).

### ✅ CORRECT - Native PostgreSQL Arrays

```csharp
public class Order {
    public Guid Id { get; set; }
    public string[] Tags { get; set; } = Array.Empty<string>();  // → text[]
    public int[] RelatedOrderIds { get; set; } = Array.Empty<int>();  // → integer[]
}

// SQL Generated:
// "Tags" text[] NOT NULL
// "RelatedOrderIds" integer[] NOT NULL
```

**Query arrays:**

```csharp
// Find orders with specific tag
var taggedOrders = await context.Orders
    .Where(o => o.Tags.Contains("Priority"))
    .ToListAsync();

// PostgreSQL array containment
var orders = await context.Orders
    .Where(o => EF.Functions.ArrayContains(o.Tags, new[] { "Priority", "Express" }))
    .ToListAsync();
```

### JSON Arrays (When Needed)

If you specifically need JSON arrays instead of PostgreSQL arrays:

```csharp
public class Order {
    public JsonDocument TagsAsJson { get; set; } = null!;  // → jsonb
}

// Configure
modelBuilder.Entity<Order>()
    .Property(o => o.TagsAsJson)
    .HasColumnType("jsonb");
```

**Prefer native arrays** unless you need JSON-specific features.

---

## AOT Compatibility

### ✅ All EF Core 10 Features Are AOT Compatible

- ✅ Complex types with JsonB: **AOT compatible**
- ✅ UUIDv7 (`Guid.CreateVersion7()`): **AOT compatible**
- ✅ Partial JSON updates: **AOT compatible**
- ✅ JSON querying: **AOT compatible**
- ✅ Array mapping: **AOT compatible**
- ✅ Generated columns: **AOT compatible**

### ❌ What to AVOID for AOT

```csharp
// ❌ Reflection-based value converters
modelBuilder.Entity<Order>()
    .Property(o => o.Status)
    .HasConversion(
        v => v.ToString(),  // OK
        v => (OrderStatus)Enum.Parse(typeof(OrderStatus), v));  // ❌ Reflection!

// ✅ Use source generators or explicit logic instead
modelBuilder.Entity<Order>()
    .Property(o => o.Status)
    .HasConversion(
        v => v.ToString(),
        v => v switch {
            "Pending" => OrderStatus.Pending,
            "Processing" => OrderStatus.Processing,
            "Shipped" => OrderStatus.Shipped,
            _ => OrderStatus.Unknown
        });
```

---

## Complete Example: Order Aggregate

```csharp
// Domain model
public class Order {
    public Guid Id { get; set; }
    public Guid CustomerId { get; set; }
    public decimal TotalAmount { get; set; }
    public DateTime CreatedAt { get; set; }
    public OrderStatus Status { get; set; }

    // Complex types → JsonB
    public Address ShippingAddress { get; set; } = null!;
    public Address BillingAddress { get; set; } = null!;
    public PaymentInfo Payment { get; set; } = null!;

    // Arrays → PostgreSQL arrays
    public string[] Tags { get; set; } = Array.Empty<string>();

    // Computed column
    public decimal TotalWithTax { get; set; }
}

public class Address {
    public string Street { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
    public string State { get; set; } = string.Empty;
    public string PostalCode { get; set; } = string.Empty;
    public string Country { get; set; } = string.Empty;
}

public class PaymentInfo {
    public string Method { get; set; } = string.Empty;
    public string Last4Digits { get; set; } = string.Empty;
    public DateTime ExpirationDate { get; set; }
}

public enum OrderStatus {
    Pending,
    Processing,
    Shipped,
    Delivered,
    Cancelled
}

// Configuration
public class OrderConfiguration : IEntityTypeConfiguration<Order> {
    public void Configure(EntityTypeBuilder<Order> builder) {
        builder.HasKey(o => o.Id);

        // Complex types to JsonB
        builder.ComplexProperty(o => o.ShippingAddress, c => c.ToJson());
        builder.ComplexProperty(o => o.BillingAddress, c => c.ToJson());
        builder.ComplexProperty(o => o.Payment, c => c.ToJson());

        // Computed column (virtual in PG 18+)
        builder.Property(o => o.TotalWithTax)
            .HasComputedColumnSql("\"TotalAmount\" * 1.08");

        // Indexes
        builder.HasIndex(o => o.CustomerId);
        builder.HasIndex(o => o.CreatedAt);

        // Array column (PostgreSQL native)
        builder.Property(o => o.Tags)
            .HasColumnType("text[]");
    }
}

// Usage
public class OrderService {
    private readonly AppDbContext _context;

    public async Task<Order> CreateOrderAsync(CreateOrderCommand command) {
        var order = new Order {
            Id = Guid.CreateVersion7(),  // UUIDv7!
            CustomerId = command.CustomerId,
            TotalAmount = command.TotalAmount,
            CreatedAt = DateTime.UtcNow,
            Status = OrderStatus.Pending,
            ShippingAddress = command.ShippingAddress,
            BillingAddress = command.BillingAddress,
            Payment = command.Payment,
            Tags = command.Tags ?? Array.Empty<string>()
        };

        await _context.Orders.AddAsync(order);
        await _context.SaveChangesAsync();

        return order;
    }

    public async Task UpdateShippingCityAsync(Guid orderId, string newCity) {
        // Partial JSON update - efficient!
        await _context.Orders
            .Where(o => o.Id == orderId)
            .ExecuteUpdateAsync(s => s
                .SetProperty(o => o.ShippingAddress.City, newCity));
    }

    public async Task<List<Order>> FindOrdersByShippingCityAsync(string city) {
        // Query JsonB property
        return await _context.Orders
            .Where(o => o.ShippingAddress.City == city)
            .OrderByDescending(o => o.CreatedAt)
            .ToListAsync();
    }
}
```

---

## Migration Example

```csharp
public partial class AddOrdersTable : Migration {
    protected override void Up(MigrationBuilder migrationBuilder) {
        migrationBuilder.CreateTable(
            name: "Orders",
            columns: table => new {
                Id = table.Column<Guid>(type: "uuid", nullable: false),
                CustomerId = table.Column<Guid>(type: "uuid", nullable: false),
                TotalAmount = table.Column<decimal>(type: "numeric", nullable: false),
                CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                Status = table.Column<int>(type: "integer", nullable: false),
                ShippingAddress = table.Column<string>(type: "jsonb", nullable: false),
                BillingAddress = table.Column<string>(type: "jsonb", nullable: false),
                Payment = table.Column<string>(type: "jsonb", nullable: false),
                Tags = table.Column<string[]>(type: "text[]", nullable: false),
                TotalWithTax = table.Column<decimal>(
                    type: "numeric",
                    nullable: false,
                    computedColumnSql: "\"TotalAmount\" * 1.08")
            },
            constraints: table => {
                table.PrimaryKey("PK_Orders", x => x.Id);
            });

        migrationBuilder.CreateIndex(
            name: "IX_Orders_CustomerId",
            table: "Orders",
            column: "CustomerId");

        migrationBuilder.CreateIndex(
            name: "IX_Orders_CreatedAt",
            table: "Orders",
            column: "CreatedAt");
    }
}
```

---

## Quick Reference

### Complex Types to JsonB
```csharp
builder.ComplexProperty(o => o.Address, c => c.ToJson());
```

### UUIDv7 IDs
```csharp
Id = Guid.CreateVersion7()  // Time-ordered, database-friendly
```

### Partial JSON Update
```csharp
await context.Orders
    .Where(o => o.Id == id)
    .ExecuteUpdateAsync(s => s.SetProperty(o => o.Address.City, "Seattle"));
```

### Query JSON Property
```csharp
var orders = await context.Orders
    .Where(o => o.Address.City == "Seattle")
    .ToListAsync();
```

### PostgreSQL Arrays
```csharp
public string[] Tags { get; set; } = Array.Empty<string>();  // → text[]
```

---

## See Also

- [EF Core 10 What's New](https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-10.0/whatsnew)
- [Npgsql EF Core 10 Release Notes](https://www.npgsql.org/efcore/release-notes/10.0.html)
- [JSON Mapping in Npgsql](https://www.npgsql.org/efcore/mapping/json.html)
- [PostgreSQL JsonB Documentation](https://www.postgresql.org/docs/current/datatype-json.html)
