using System.Diagnostics.CodeAnalysis;
using ECommerce.BFF.API.Generated;
using ECommerce.BFF.API.Hubs;
using ECommerce.BFF.API.Lenses;
using ECommerce.Contracts.Generated;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Npgsql;
using Testcontainers.PostgreSql;
using Whizbang.Core;
using Whizbang.Core.Lenses;
using Whizbang.Core.Perspectives;
using Whizbang.Data.EFCore.Postgres;

namespace ECommerce.BFF.API.Tests.TestHelpers;

/// <summary>
/// Helper class for setting up EF Core infrastructure with Whizbang unified API for testing.
/// Provides IPerspectiveStore and ILensQuery instances configured with PostgreSQL via Testcontainers.
/// </summary>
public sealed class EFCoreTestHelper : IAsyncDisposable {
  private readonly ServiceProvider _serviceProvider;
  private readonly BffDbContext _dbContext;
  private readonly PostgreSqlContainer _postgresContainer;

  [RequiresDynamicCode("EF Core in tests may use dynamic code")]
  [RequiresUnreferencedCode("EF Core in tests may use unreferenced code")]
  public EFCoreTestHelper() {
    // Create and start PostgreSQL container
    _postgresContainer = new PostgreSqlBuilder()
      .WithImage("postgres:17-alpine")
      .WithDatabase($"bff_test_{Guid.CreateVersion7():N}")
      .Build();

    _postgresContainer.StartAsync().GetAwaiter().GetResult();

    var services = new ServiceCollection();

    // Add logging
    services.AddSingleton<ILoggerFactory>(NullLoggerFactory.Instance);
    services.AddSingleton(typeof(ILogger<>), typeof(NullLogger<>));

    // Register JsonSerializerOptions for Npgsql JSONB serialization
    var jsonOptions = ECommerce.Contracts.Generated.WhizbangJsonContext.CreateOptions();
    services.AddSingleton(jsonOptions);

    // Add DbContext with PostgreSQL using NpgsqlDataSource
    // IMPORTANT: ConfigureJsonOptions() MUST be called BEFORE EnableDynamicJson() (Npgsql bug #5562)
    // This registers WhizbangId JSON converters for JSONB serialization
    var connectionString = _postgresContainer.GetConnectionString();
    var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);
    dataSourceBuilder.ConfigureJsonOptions(jsonOptions);
    dataSourceBuilder.EnableDynamicJson();
    var dataSource = dataSourceBuilder.Build();
    services.AddSingleton(dataSource);

    services.AddDbContext<BffDbContext>(options => {
      options.UseNpgsql(dataSource);
    });

    // Register unified Whizbang API with EF Core Postgres driver
    _ = services
      .AddWhizbang()
      .WithEFCore<BffDbContext>()
      .WithDriver.Postgres;

    // Register perspective runners (generated by PerspectiveRunnerRegistryGenerator)
    _ = services.AddPerspectiveRunners();

    // Register concrete perspective types for testing
    services.AddScoped<ECommerce.BFF.API.Perspectives.ProductCatalogPerspective>();
    services.AddScoped<ECommerce.BFF.API.Perspectives.InventoryLevelsPerspective>();

    // Register lenses (high-level query interfaces)
    services.AddScoped<ECommerce.BFF.API.Lenses.IOrderLens, ECommerce.BFF.API.Lenses.OrderLens>();
    services.AddScoped<ECommerce.BFF.API.Lenses.IProductCatalogLens, ECommerce.BFF.API.Lenses.ProductCatalogLens>();
    services.AddScoped<ECommerce.BFF.API.Lenses.IInventoryLevelsLens, ECommerce.BFF.API.Lenses.InventoryLevelsLens>();

    // Register aggregate ID extractor
    services.AddWhizbangAggregateIdExtractor();

    // Add simple mock for SignalR hub context
    services.AddSingleton<IHubContext<ProductInventoryHub>>(new TestHubContext());

    _serviceProvider = services.BuildServiceProvider();
    _dbContext = _serviceProvider.GetRequiredService<BffDbContext>();

    // Ensure Whizbang database schema is created (tables + PostgreSQL functions)
    _dbContext.EnsureWhizbangDatabaseInitializedAsync().GetAwaiter().GetResult();
  }

  /// <summary>
  /// Gets an IPerspectiveStore for the specified model type.
  /// </summary>
  public IPerspectiveStore<TModel> GetPerspectiveStore<TModel>() where TModel : class {
    return _serviceProvider.GetRequiredService<IPerspectiveStore<TModel>>();
  }

  /// <summary>
  /// Gets an ILensQuery for the specified model type.
  /// </summary>
  public ILensQuery<TModel> GetLensQuery<TModel>() where TModel : class {
    return _serviceProvider.GetRequiredService<ILensQuery<TModel>>();
  }

  /// <summary>
  /// Gets the mock IHubContext for testing SignalR notifications.
  /// </summary>
  public IHubContext<ProductInventoryHub> GetHubContext() {
    return _serviceProvider.GetRequiredService<IHubContext<ProductInventoryHub>>();
  }

  /// <summary>
  /// Gets an ILogger for the specified type.
  /// </summary>
  public ILogger<T> GetLogger<T>() {
    return _serviceProvider.GetRequiredService<ILogger<T>>();
  }

  /// <summary>
  /// Cleans up all test data from the database.
  /// </summary>
  public async Task CleanupDatabaseAsync(CancellationToken cancellationToken = default) {
    // Truncate only perspective tables (BFF doesn't have outbox/inbox/event_store)
    await _dbContext.Database.ExecuteSqlRawAsync(@"
      TRUNCATE TABLE wh_per_product_dto CASCADE;
      TRUNCATE TABLE wh_per_inventory_level_dto CASCADE;
      TRUNCATE TABLE wh_per_order_read_model CASCADE;
    ", cancellationToken);
  }

  public async ValueTask DisposeAsync() {
    await _dbContext.DisposeAsync();
    await _serviceProvider.DisposeAsync();
    await _postgresContainer.DisposeAsync();
  }
}

/// <summary>
/// Simple test double for IHubContext that does nothing.
/// SignalR notifications are not the focus of perspective/lens tests.
/// </summary>
internal class TestHubContext : IHubContext<ProductInventoryHub> {
  public IHubClients Clients { get; } = new TestHubClients();
  public IGroupManager Groups { get; } = new TestGroupManager();
}

internal class TestHubClients : IHubClients {
  private readonly TestClientProxy _clientProxy = new();

  public IClientProxy All => _clientProxy;
  public IClientProxy AllExcept(IReadOnlyList<string> excludedConnectionIds) => _clientProxy;
  public IClientProxy Client(string connectionId) => _clientProxy;
  public IClientProxy Clients(IReadOnlyList<string> connectionIds) => _clientProxy;
  public IClientProxy Group(string groupName) => _clientProxy;
  public IClientProxy Groups(IReadOnlyList<string> groupNames) => _clientProxy;
  public IClientProxy GroupExcept(string groupName, IReadOnlyList<string> excludedConnectionIds) => _clientProxy;
  public IClientProxy User(string userId) => _clientProxy;
  public IClientProxy Users(IReadOnlyList<string> userIds) => _clientProxy;
}

internal class TestClientProxy : IClientProxy {
  public Task SendCoreAsync(string method, object?[] args, CancellationToken cancellationToken = default) {
    // Do nothing - SignalR notifications are not the focus of these tests
    return Task.CompletedTask;
  }
}

internal class TestGroupManager : IGroupManager {
  public Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken = default) {
    // Do nothing - SignalR group management is not the focus of these tests
    return Task.CompletedTask;
  }

  public Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken = default) {
    // Do nothing - SignalR group management is not the focus of these tests
    return Task.CompletedTask;
  }
}
