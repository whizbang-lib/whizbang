using System.Diagnostics.CodeAnalysis;
using Dapper;
using ECommerce.BFF.API.Generated;
using ECommerce.BFF.API.Hubs;
using ECommerce.BFF.API.Lenses;
using ECommerce.Contracts.Generated;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Npgsql;
using Whizbang.Core;
using Whizbang.Core.Lenses;
using Whizbang.Core.Perspectives;
using Whizbang.Data.EFCore.Postgres;
using Whizbang.Testing.Containers;

namespace ECommerce.BFF.API.Tests.TestHelpers;

/// <summary>
/// Helper class for setting up EF Core infrastructure with Whizbang unified API for testing.
/// Provides IPerspectiveStore and ILensQuery instances configured with PostgreSQL via Testcontainers.
/// </summary>
public sealed class EFCoreTestHelper : IAsyncDisposable {
  private readonly ServiceProvider _serviceProvider;
  private readonly BffDbContext _dbContext;
  private readonly string _databaseName;
  private readonly string _connectionString;

  [RequiresDynamicCode("EF Core in tests may use dynamic code")]
  [RequiresUnreferencedCode("EF Core in tests may use unreferenced code")]
  public EFCoreTestHelper() {
    // Initialize shared container and create per-helper database
    SharedPostgresContainer.InitializeAsync().GetAwaiter().GetResult();

    _databaseName = $"bff_test_{Guid.NewGuid():N}";

    // Create the database using admin connection
    using (var adminConnection = new NpgsqlConnection(SharedPostgresContainer.ConnectionString)) {
      adminConnection.Open();
      adminConnection.Execute($"CREATE DATABASE {_databaseName}");
    }

    // Build connection string for the new database
    var builder = new NpgsqlConnectionStringBuilder(SharedPostgresContainer.ConnectionString) {
      Database = _databaseName
    };
    _connectionString = builder.ConnectionString;

    var services = new ServiceCollection();

    // Add logging
    services.AddSingleton<ILoggerFactory>(NullLoggerFactory.Instance);
    services.AddSingleton(typeof(ILogger<>), typeof(NullLogger<>));

    // Register JsonSerializerOptions for Npgsql JSONB serialization
    var jsonOptions = ECommerce.Contracts.Generated.WhizbangJsonContext.CreateOptions();
    services.AddSingleton(jsonOptions);

    // Add DbContext with PostgreSQL using NpgsqlDataSource
    // IMPORTANT: ConfigureJsonOptions() MUST be called BEFORE EnableDynamicJson() (Npgsql bug #5562)
    // This registers WhizbangId JSON converters for JSONB serialization
    var connectionString = _connectionString;
    var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);
    dataSourceBuilder.ConfigureJsonOptions(jsonOptions);
    dataSourceBuilder.EnableDynamicJson();
    var dataSource = dataSourceBuilder.Build();
    services.AddSingleton(dataSource);

    services.AddDbContext<BffDbContext>(options => {
      options.UseNpgsql(dataSource);
    });

    // Register unified Whizbang API with EF Core Postgres driver
    _ = services
      .AddWhizbang()
      .WithEFCore<BffDbContext>()
      .WithDriver.Postgres;

    // Register perspective runners (generated by PerspectiveRunnerRegistryGenerator)
    _ = services.AddPerspectiveRunners();

    // Register concrete perspective types for testing
    services.AddScoped<ECommerce.BFF.API.Perspectives.ProductCatalogPerspective>();
    services.AddScoped<ECommerce.BFF.API.Perspectives.InventoryLevelsPerspective>();

    // Register lenses (high-level query interfaces)
    services.AddScoped<ECommerce.BFF.API.Lenses.IOrderLens, ECommerce.BFF.API.Lenses.OrderLens>();
    services.AddScoped<ECommerce.BFF.API.Lenses.IProductCatalogLens, ECommerce.BFF.API.Lenses.ProductCatalogLens>();
    services.AddScoped<ECommerce.BFF.API.Lenses.IInventoryLevelsLens, ECommerce.BFF.API.Lenses.InventoryLevelsLens>();

    // Register aggregate ID extractor
    services.AddWhizbangAggregateIdExtractor();

    // Add simple mock for SignalR hub context
    services.AddSingleton<IHubContext<ProductInventoryHub>>(new TestHubContext());

    _serviceProvider = services.BuildServiceProvider();
    _dbContext = _serviceProvider.GetRequiredService<BffDbContext>();

    // Ensure Whizbang database schema is created (tables + PostgreSQL functions)
    _dbContext.EnsureWhizbangDatabaseInitializedAsync().GetAwaiter().GetResult();
  }

  /// <summary>
  /// Gets an IPerspectiveStore for the specified model type.
  /// </summary>
  public IPerspectiveStore<TModel> GetPerspectiveStore<TModel>() where TModel : class {
    return _serviceProvider.GetRequiredService<IPerspectiveStore<TModel>>();
  }

  /// <summary>
  /// Gets an ILensQuery for the specified model type.
  /// </summary>
  public ILensQuery<TModel> GetLensQuery<TModel>() where TModel : class {
    return _serviceProvider.GetRequiredService<ILensQuery<TModel>>();
  }

  /// <summary>
  /// Gets the mock IHubContext for testing SignalR notifications.
  /// </summary>
  public IHubContext<ProductInventoryHub> GetHubContext() {
    return _serviceProvider.GetRequiredService<IHubContext<ProductInventoryHub>>();
  }

  /// <summary>
  /// Gets an ILogger for the specified type.
  /// </summary>
  public ILogger<T> GetLogger<T>() {
    return _serviceProvider.GetRequiredService<ILogger<T>>();
  }

  /// <summary>
  /// Cleans up all test data from the database.
  /// </summary>
  public async Task CleanupDatabaseAsync(CancellationToken cancellationToken = default) {
    // Truncate only perspective tables (BFF doesn't have outbox/inbox/event_store)
    await _dbContext.Database.ExecuteSqlRawAsync(@"
      TRUNCATE TABLE wh_per_product_dto CASCADE;
      TRUNCATE TABLE wh_per_inventory_level_dto CASCADE;
      TRUNCATE TABLE wh_per_order_read_model CASCADE;
    ", cancellationToken);
  }

  public async ValueTask DisposeAsync() {
    await _dbContext.DisposeAsync();
    await _serviceProvider.DisposeAsync();

    // Drop the per-helper database
    try {
      await using var adminConnection = new NpgsqlConnection(SharedPostgresContainer.ConnectionString);
      await adminConnection.OpenAsync();

      // Terminate existing connections to the database
      await adminConnection.ExecuteAsync($@"
        SELECT pg_terminate_backend(pg_stat_activity.pid)
        FROM pg_stat_activity
        WHERE pg_stat_activity.datname = '{_databaseName}'
        AND pid <> pg_backend_pid()");

      await adminConnection.ExecuteAsync($"DROP DATABASE IF EXISTS {_databaseName}");
    } catch {
      // Ignore cleanup errors - database may already be dropped
    }
  }
}

/// <summary>
/// Simple test double for IHubContext that does nothing.
/// SignalR notifications are not the focus of perspective/lens tests.
/// </summary>
internal class TestHubContext : IHubContext<ProductInventoryHub> {
  public IHubClients Clients { get; } = new TestHubClients();
  public IGroupManager Groups { get; } = new TestGroupManager();
}

internal class TestHubClients : IHubClients {
  private readonly TestClientProxy _clientProxy = new();

  public IClientProxy All => _clientProxy;
  public IClientProxy AllExcept(IReadOnlyList<string> excludedConnectionIds) => _clientProxy;
  public IClientProxy Client(string connectionId) => _clientProxy;
  public IClientProxy Clients(IReadOnlyList<string> connectionIds) => _clientProxy;
  public IClientProxy Group(string groupName) => _clientProxy;
  public IClientProxy Groups(IReadOnlyList<string> groupNames) => _clientProxy;
  public IClientProxy GroupExcept(string groupName, IReadOnlyList<string> excludedConnectionIds) => _clientProxy;
  public IClientProxy User(string userId) => _clientProxy;
  public IClientProxy Users(IReadOnlyList<string> userIds) => _clientProxy;
}

internal class TestClientProxy : IClientProxy {
  public Task SendCoreAsync(string method, object?[] args, CancellationToken cancellationToken = default) {
    // Do nothing - SignalR notifications are not the focus of these tests
    return Task.CompletedTask;
  }
}

internal class TestGroupManager : IGroupManager {
  public Task AddToGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken = default) {
    // Do nothing - SignalR group management is not the focus of these tests
    return Task.CompletedTask;
  }

  public Task RemoveFromGroupAsync(string connectionId, string groupName, CancellationToken cancellationToken = default) {
    // Do nothing - SignalR group management is not the focus of these tests
    return Task.CompletedTask;
  }
}
