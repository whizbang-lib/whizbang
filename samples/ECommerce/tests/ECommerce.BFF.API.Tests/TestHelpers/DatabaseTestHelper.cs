using Dapper;
using ECommerce.BFF.API;
using ECommerce.BFF.API.Generated;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Npgsql;
using Whizbang.Core;
using Whizbang.Core.Generated;
using Whizbang.Data.EFCore.Postgres;
using Whizbang.Testing.Containers;

namespace ECommerce.BFF.API.Tests.TestHelpers;

/// <summary>
/// Helper class for managing PostgreSQL test databases via SharedPostgresContainer for BFF.API tests.
/// Provides DbContext and all EF Core infrastructure for testing.
/// </summary>
public sealed class DatabaseTestHelper : IAsyncDisposable {
  private string? _fixtureDatabaseName;  // Unique database name for this fixture instance
  private string? _connectionString;  // Connection string pointing to the fixture's unique database
  private bool _isInitialized;
  private IServiceProvider? _serviceProvider;

  public DatabaseTestHelper() {
    Console.WriteLine("[DatabaseTestHelper] Using SharedPostgresContainer for PostgreSQL");
  }

  /// <summary>
  /// Creates and returns a configured IServiceProvider with all EF Core infrastructure registered.
  /// </summary>
  public async Task<IServiceProvider> CreateServiceProviderAsync(CancellationToken cancellationToken = default) {
    if (!_isInitialized) {
      // Initialize SharedPostgresContainer
      await SharedPostgresContainer.InitializeAsync(cancellationToken);

      // Create a unique database for this fixture instance
      _fixtureDatabaseName = $"fixture_{Guid.NewGuid():N}";
      Console.WriteLine($"[DatabaseTestHelper] Creating unique database: {_fixtureDatabaseName}");

      await using (var conn = new NpgsqlConnection(SharedPostgresContainer.ConnectionString)) {
        await conn.OpenAsync(cancellationToken);
        await conn.ExecuteAsync($"CREATE DATABASE \"{_fixtureDatabaseName}\"");
      }

      // Build connection string with the new database name
      var builder = new NpgsqlConnectionStringBuilder(SharedPostgresContainer.ConnectionString) {
        Database = _fixtureDatabaseName
      };
      _connectionString = builder.ConnectionString;

      var services = new ServiceCollection();

      // Register DbContext
      services.AddDbContext<BffDbContext>(options =>
        options.UseNpgsql(_connectionString));

      // Register Whizbang infrastructure with EF Core + Postgres driver
      _ = services.AddWhizbang()
        .WithEFCore<BffDbContext>()
        .WithDriver.Postgres;

      // Register perspective runners (generated by PerspectiveRunnerRegistryGenerator)
      _ = services.AddPerspectiveRunners();

      // Add NullLogger for all logger dependencies
      services.AddSingleton(typeof(ILogger<>), typeof(NullLogger<>));

      _serviceProvider = services.BuildServiceProvider();

      // Initialize schema (creates tables + PostgreSQL functions)
      await using var scope = _serviceProvider.CreateAsyncScope();
      var dbContext = scope.ServiceProvider.GetRequiredService<BffDbContext>();
      await dbContext.EnsureWhizbangDatabaseInitializedAsync();

      _isInitialized = true;
    }

    return _serviceProvider!;
  }

  /// <summary>
  /// Gets the connection string for raw SQL operations if needed.
  /// </summary>
  public async Task<string> GetConnectionStringAsync(CancellationToken cancellationToken = default) {
    if (!_isInitialized) {
      await CreateServiceProviderAsync(cancellationToken);
    }
    return _connectionString ?? throw new InvalidOperationException("DatabaseTestHelper not initialized");
  }

  /// <summary>
  /// Cleans up all test data from the database.
  /// </summary>
  public async Task CleanupDatabaseAsync(CancellationToken cancellationToken = default) {
    if (!_isInitialized || _serviceProvider == null) {
      return;
    }

    await using var scope = _serviceProvider.CreateAsyncScope();
    var dbContext = scope.ServiceProvider.GetRequiredService<BffDbContext>();

    // Truncate all perspective tables
    await dbContext.Database.ExecuteSqlRawAsync(@"
      TRUNCATE TABLE wh_per_product_dto CASCADE;
      TRUNCATE TABLE wh_per_inventory_level_dto CASCADE;
      TRUNCATE TABLE wh_per_order_summary_dto CASCADE;
      TRUNCATE TABLE wh_outbox CASCADE;
      TRUNCATE TABLE wh_inbox CASCADE;
      TRUNCATE TABLE wh_event_store CASCADE;
    ", cancellationToken);
  }

  public async ValueTask DisposeAsync() {
    if (_serviceProvider is IAsyncDisposable asyncDisposable) {
      await asyncDisposable.DisposeAsync();
    }

    // Drop the fixture's unique database from SharedPostgresContainer
    // The container itself is NOT disposed - it's shared across all tests
    if (_fixtureDatabaseName != null) {
      try {
        await using var conn = new NpgsqlConnection(SharedPostgresContainer.ConnectionString);
        await conn.OpenAsync();
        // Terminate any remaining connections to the database before dropping
        await conn.ExecuteAsync($@"
          SELECT pg_terminate_backend(pid)
          FROM pg_stat_activity
          WHERE datname = '{_fixtureDatabaseName}' AND pid <> pg_backend_pid()");
        await conn.ExecuteAsync($"DROP DATABASE IF EXISTS \"{_fixtureDatabaseName}\"");
        Console.WriteLine($"[DatabaseTestHelper] Dropped database: {_fixtureDatabaseName}");
      } catch (Exception ex) {
        Console.WriteLine($"[DatabaseTestHelper] Warning: Failed to drop database {_fixtureDatabaseName}: {ex.Message}");
      }
    }
  }
}
