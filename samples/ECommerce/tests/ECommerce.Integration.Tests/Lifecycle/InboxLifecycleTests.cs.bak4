using ECommerce.Contracts.Commands;
using ECommerce.Contracts.Events;
using ECommerce.Integration.Tests.Fixtures;
using Microsoft.Extensions.DependencyInjection;
using Whizbang.Core.Messaging;

namespace ECommerce.Integration.Tests.Lifecycle;

/// <summary>
/// Integration tests for all 4 Inbox lifecycle stages.
/// Validates that lifecycle receptors fire at correct points around receptor invocation when messages are received.
/// </summary>
/// <remarks>
/// <para><strong>Hook Location</strong>: ServiceBusConsumerWorker.cs, around ProcessInboxWorkAsync()</para>
/// <para><strong>Stages Tested</strong>:</para>
/// <list type="bullet">
///   <item>PreInboxInline - Before invoking local receptor (blocking)</item>
///   <item>PreInboxAsync - Parallel with receptor invocation (non-blocking)</item>
///   <item>PostInboxAsync - After receptor completes (non-blocking)</item>
///   <item>PostInboxInline - After receptor completes (blocking)</item>
/// </list>
/// </remarks>
/// <docs>core-concepts/lifecycle-stages</docs>
/// <docs>testing/lifecycle-synchronization</docs>
[Category("Integration")]
[Category("Lifecycle")]
public class InboxLifecycleTests {
  private static ServiceBusIntegrationFixture? _fixture;

  [Before(Test)]
  public async Task SetupAsync() {
    _fixture = new ServiceBusIntegrationFixture();
    await _fixture.InitializeAsync();
  }

  [After(Test)]
  public async Task CleanupAsync() {
    if (_fixture != null) {
      await _fixture.DisposeAsync();
    }
  }

  // ========================================
  // PreInboxInline Tests (Blocking)
  // ========================================

  /// <summary>
  /// Verifies that PreInboxInline lifecycle stage fires before receptor invocation (blocking).
  /// Receptor invocation should wait for this lifecycle receptor to complete.
  /// </summary>
  [Test]
  public async Task PreInboxInline_FiresBeforeReceptorInvocation_BlocksUntilCompleteAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();

    // Act - Register receptor for ProductCreatedEvent (received by BFF from Service Bus)
    var receptor = await _fixture.BffHost.WaitForPreInboxInlineAsync<ProductCreatedEvent>(
      timeoutMilliseconds: 20000);

    await dispatcher.SendAsync(command);

    // Assert - Verify receptor was invoked
    await Assert.That(receptor.InvocationCount).IsEqualTo(1);
    await Assert.That(receptor.LastMessage).IsNotNull();
    await Assert.That(receptor.LastMessage!.ProductId).IsEqualTo(command.ProductId);
  }

  // ========================================
  // PreInboxAsync Tests (Non-Blocking)
  // ========================================

  /// <summary>
  /// Verifies that PreInboxAsync lifecycle stage fires parallel with receptor invocation (non-blocking).
  /// Should use Task.Run and not block receptor invocation.
  /// </summary>
  [Test]
  public async Task PreInboxAsync_FiresParallelWithReceptor_NonBlockingAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();

    // Act - Register receptor for ProductCreatedEvent (received by BFF)
    var receptor = await _fixture.BffHost.WaitForPreInboxAsyncAsync<ProductCreatedEvent>(
      timeoutMilliseconds: 20000);

    await dispatcher.SendAsync(command);

    // Assert - Verify receptor was invoked
    await Assert.That(receptor.InvocationCount).IsEqualTo(1);
    await Assert.That(receptor.LastMessage).IsNotNull();
    await Assert.That(receptor.LastMessage!.ProductId).IsEqualTo(command.ProductId);
  }

  /// <summary>
  /// Verifies that PreInboxAsync may still be running when receptor completes.
  /// Tests the "receptor may complete before this stage finishes" guarantee.
  /// </summary>
  [Test]
  public async Task PreInboxAsync_MayCompleteAfterReceptor_NonBlockingGuaranteeAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();
    var completionSource = new TaskCompletionSource<bool>();
    var receptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(completionSource);

    var registry = _fixture.BffHost.Services.GetRequiredService<ILifecycleReceptorRegistry>();
    registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PreInboxAsync);

    try {
      // Act - Dispatch command
      await dispatcher.SendAsync(command);

      // Wait for PreInboxAsync stage (non-blocking, may complete late)
      await completionSource.Task.WaitAsync(TimeSpan.FromSeconds(20));

      // Assert - PreInboxAsync should have completed eventually
      await Assert.That(receptor.InvocationCount).IsEqualTo(1);

      // Verify that receptor processing happened (perspective materialized)
      await _fixture.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>("ProductCatalog");

    } finally {
      registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PreInboxAsync);
    }
  }

  // ========================================
  // PostInboxAsync Tests (Non-Blocking)
  // ========================================

  /// <summary>
  /// Verifies that PostInboxAsync lifecycle stage fires after receptor completes (non-blocking).
  /// Should use Task.Run and not block next steps.
  /// </summary>
  [Test]
  public async Task PostInboxAsync_FiresAfterReceptorCompletes_NonBlockingAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();

    // Act - Register receptor for ProductCreatedEvent (received by BFF)
    var receptor = await _fixture.BffHost.WaitForPostInboxAsyncAsync<ProductCreatedEvent>(
      timeoutMilliseconds: 20000);

    await dispatcher.SendAsync(command);

    // Assert - Verify receptor was invoked
    await Assert.That(receptor.InvocationCount).IsEqualTo(1);
    await Assert.That(receptor.LastMessage).IsNotNull();
    await Assert.That(receptor.LastMessage!.ProductId).IsEqualTo(command.ProductId);
  }

  /// <summary>
  /// Verifies that PostInboxAsync fires after receptor has completed successfully.
  /// Tests the "receptor has completed successfully" guarantee.
  /// </summary>
  [Test]
  public async Task PostInboxAsync_FiresAfterSuccessfulCompletion_GuaranteesReceptorFinishedAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();
    var completionSource = new TaskCompletionSource<bool>();
    var receptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(completionSource);

    var registry = _fixture.BffHost.Services.GetRequiredService<ILifecycleReceptorRegistry>();
    registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PostInboxAsync);

    try {
      // Act - Dispatch command
      await dispatcher.SendAsync(command);

      // Wait for PostInboxAsync stage
      await completionSource.Task.WaitAsync(TimeSpan.FromSeconds(20));

      // Assert - At this point, PostInboxAsync has fired
      // Receptor should have completed successfully
      await Assert.That(receptor.InvocationCount).IsEqualTo(1);

      // Verify that receptor processing completed (perspective should be materialized)
      await _fixture.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>("ProductCatalog");

    } finally {
      registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PostInboxAsync);
    }
  }

  // ========================================
  // PostInboxInline Tests (Blocking)
  // ========================================

  /// <summary>
  /// Verifies that PostInboxInline lifecycle stage fires after receptor completes (blocking).
  /// Next step should wait for this lifecycle receptor to complete.
  /// </summary>
  [Test]
  public async Task PostInboxInline_FiresAfterReceptorCompletes_BlocksUntilCompleteAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();

    // Act - Register receptor for ProductCreatedEvent (received by BFF)
    var receptor = await _fixture.BffHost.WaitForPostInboxInlineAsync<ProductCreatedEvent>(
      timeoutMilliseconds: 20000);

    await dispatcher.SendAsync(command);

    // Assert - Verify receptor was invoked
    await Assert.That(receptor.InvocationCount).IsEqualTo(1);
    await Assert.That(receptor.LastMessage).IsNotNull();
    await Assert.That(receptor.LastMessage!.ProductId).IsEqualTo(command.ProductId);
  }

  // ========================================
  // Stage Ordering Tests
  // ========================================

  /// <summary>
  /// Verifies that all 4 Inbox stages fire in correct order:
  /// PreInboxInline → PreInboxAsync (parallel with receptor) → PostInboxAsync → PostInboxInline
  /// </summary>
  [Test]
  public async Task InboxStages_FireInCorrectOrder_AllStagesInvokedAsync() {
    // Arrange
    var command = new CreateProductCommand {
      ProductId = ProductId.New(),
      Name = "Test Product",
      Description = "Test Description",
      Price = 99.99m,
      InitialStock = 10
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();
    var registry = _fixture.BffHost.Services.GetRequiredService<ILifecycleReceptorRegistry>();

    // Create receptors for all 4 stages
    var preInlineCompletion = new TaskCompletionSource<bool>();
    var preAsyncCompletion = new TaskCompletionSource<bool>();
    var postAsyncCompletion = new TaskCompletionSource<bool>();
    var postInlineCompletion = new TaskCompletionSource<bool>();

    var preInlineReceptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(preInlineCompletion);
    var preAsyncReceptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(preAsyncCompletion);
    var postAsyncReceptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(postAsyncCompletion);
    var postInlineReceptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(postInlineCompletion);

    // Register all receptors
    registry.Register<ProductCreatedEvent>(preInlineReceptor, LifecycleStage.PreInboxInline);
    registry.Register<ProductCreatedEvent>(preAsyncReceptor, LifecycleStage.PreInboxAsync);
    registry.Register<ProductCreatedEvent>(postAsyncReceptor, LifecycleStage.PostInboxAsync);
    registry.Register<ProductCreatedEvent>(postInlineReceptor, LifecycleStage.PostInboxInline);

    try {
      // Act - Dispatch command (will publish event to Service Bus, BFF will receive it)
      await dispatcher.SendAsync(command);

      // Wait for all stages to complete (with timeout)
      await Task.WhenAll(
        preInlineCompletion.Task,
        preAsyncCompletion.Task,
        postAsyncCompletion.Task,
        postInlineCompletion.Task
      ).WaitAsync(TimeSpan.FromSeconds(25));

      // Assert - All stages should have been invoked
      await Assert.That(preInlineReceptor.InvocationCount).IsEqualTo(1);
      await Assert.That(preAsyncReceptor.InvocationCount).IsEqualTo(1);
      await Assert.That(postAsyncReceptor.InvocationCount).IsEqualTo(1);
      await Assert.That(postInlineReceptor.InvocationCount).IsEqualTo(1);

    } finally {
      // Unregister all receptors
      registry.Unregister<ProductCreatedEvent>(preInlineReceptor, LifecycleStage.PreInboxInline);
      registry.Unregister<ProductCreatedEvent>(preAsyncReceptor, LifecycleStage.PreInboxAsync);
      registry.Unregister<ProductCreatedEvent>(postAsyncReceptor, LifecycleStage.PostInboxAsync);
      registry.Unregister<ProductCreatedEvent>(postInlineReceptor, LifecycleStage.PostInboxInline);
    }
  }

  /// <summary>
  /// Verifies that multiple inbox messages trigger all Inbox stages for each message.
  /// </summary>
  [Test]
  public async Task InboxStages_MultipleMessages_AllStagesFireForEachAsync() {
    // Arrange
    var commands = new[] {
      new CreateProductCommand {
        ProductId = ProductId.New(),
        Name = "Product 1",
        Description = "Description 1",
        Price = 10.00m,
        InitialStock = 5
      },
      new CreateProductCommand {
        ProductId = ProductId.New(),
        Name = "Product 2",
        Description = "Description 2",
        Price = 20.00m,
        InitialStock = 15
      }
    };

    var dispatcher = _fixture.InventoryHost.Services.GetRequiredService<IDispatcher>();
    var completionSource = new TaskCompletionSource<bool>();
    var receptor = new GenericLifecycleCompletionReceptor<ProductCreatedEvent>(completionSource);

    var registry = _fixture.BffHost.Services.GetRequiredService<ILifecycleReceptorRegistry>();
    registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PostInboxInline);

    try {
      // Act - Dispatch multiple commands
      foreach (var command in commands) {
        await dispatcher.SendAsync(command);
      }

      // Wait for last event to complete PostInboxInline
      await completionSource.Task.WaitAsync(TimeSpan.FromSeconds(30));

      // Assert - Receptor should have been invoked at least once
      await Assert.That(receptor.InvocationCount).IsGreaterThanOrEqualTo(1);

    } finally {
      registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PostInboxInline);
    }
  }
}
