using System.Text.Json;
using ECommerce.BFF.API;
using ECommerce.BFF.API.Generated;
using ECommerce.BFF.API.GraphQL;
using ECommerce.BFF.API.Hubs;
using ECommerce.BFF.API.Lenses;
using ECommerce.BFF.API.Perspectives;
using ECommerce.Contracts.Events;
using ECommerce.Contracts.Generated;
using FastEndpoints;
using FastEndpoints.Swagger;
using Microsoft.EntityFrameworkCore;
using Whizbang.Core;
using Whizbang.Core.Generated;
using Whizbang.Core.Lenses;
using Whizbang.Core.Messaging;
using Whizbang.Core.Observability;
using Whizbang.Core.Perspectives;
using Whizbang.Core.Transports;
using Whizbang.Core.Workers;
using Whizbang.Data.EFCore.Postgres;
using Whizbang.Data.EFCore.Postgres.Generated;
using Whizbang.Transports.AzureServiceBus;

var builder = WebApplication.CreateBuilder(args);

// Configure detailed console logging for WorkCoordinator
builder.Logging.ClearProviders();
builder.Logging.AddSimpleConsole(options => {
  options.SingleLine = true;
  options.TimestampFormat = "[HH:mm:ss] ";
  options.IncludeScopes = true;
});
builder.Logging.SetMinimumLevel(Microsoft.Extensions.Logging.LogLevel.Debug);

// Add service defaults (telemetry, health checks, service discovery)
builder.AddServiceDefaults();

// Get connection strings from Aspire configuration
var postgresConnection = builder.Configuration.GetConnectionString("bffdb")
    ?? throw new InvalidOperationException("PostgreSQL connection string 'bffdb' not found");
var serviceBusConnection = builder.Configuration.GetConnectionString("servicebus")
    ?? throw new InvalidOperationException("Azure Service Bus connection string 'servicebus' not found");
var angularUrl = builder.Configuration["services:ui:http:0"]
    ?? builder.Configuration.GetConnectionString("ui")
    ?? "http://localhost:4200";  // Fallback for local development without Aspire

// IMPORTANT: Force Contracts assembly to load BEFORE creating JsonSerializerOptions
// This ensures ECommerce.Contracts.Generated.MessageJsonContext ModuleInitializer runs
// and registers its WhizbangId converters (OrderId, ProductId, CustomerId) with JsonContextRegistry
// BEFORE AddAzureServiceBusTransport() calls JsonContextRegistry.CreateCombinedOptions()
_ = typeof(ECommerce.Contracts.Commands.CreateProductCommand).Assembly;

// Register combined JsonSerializerOptions in DI container for ServiceBusConsumerWorker
// Must be registered AFTER forcing Contracts assembly to load (above)
builder.Services.AddSingleton(Whizbang.Core.Serialization.JsonContextRegistry.CreateCombinedOptions());

// Register Azure Service Bus transport
// Note: Transport creates JsonSerializerOptions from registry (now includes ECommerce.Contracts converters)
builder.Services.AddAzureServiceBusTransport(serviceBusConnection);
builder.Services.AddAzureServiceBusHealthChecks();

// Add trace store for observability
builder.Services.AddSingleton<ITraceStore, InMemoryTraceStore>();

// Register service instance provider (MUST be before workers that depend on it)
builder.Services.AddSingleton<IServiceInstanceProvider, ServiceInstanceProvider>();

// Register OrderedStreamProcessor for message ordering in ServiceBusConsumerWorker
builder.Services.AddSingleton<OrderedStreamProcessor>();

// Configure WorkCoordinatorPublisherOptions from appsettings.json
// Use AddOptions().Bind() for AOT compatibility (instead of Configure<T>())
builder.Services.AddOptions<WorkCoordinatorPublisherOptions>()
  .Bind(builder.Configuration.GetSection("WorkCoordinatorPublisher"));

// Register EF Core DbContext for perspectives with PostgreSQL
builder.Services.AddDbContext<BffDbContext>(options =>
  options.UseNpgsql(postgresConnection));

// Register unified Whizbang API with EF Core Postgres driver
// This automatically registers ALL infrastructure:
// - IInbox, IOutbox, IEventStore (using EF Core implementations)
// - IPerspectiveStore<T> and ILensQuery<T> for all discovered perspective models
// Source generator discovers perspective models from BffDbContext
_ = builder.Services
  .AddWhizbang()
  .WithEFCore<BffDbContext>()
  .WithDriver.Postgres;

// Register perspectives (ProductCatalogPerspective, OrderPerspective, etc.)
// Generated by PerspectiveDiscoveryGenerator - registers all IPerspectiveOf<TEvent> implementations
_ = builder.Services.AddWhizbangPerspectives();

// Register dispatcher (required for SeedMutations and command dispatching)
// Generated by ReceptorDiscoveryGenerator - creates dispatcher with outbox fallback for 0-receptor services
builder.Services.AddWhizbangDispatcher();

// Register lenses (readonly repositories - high-level interface)
builder.Services.AddScoped<IOrderLens, OrderLens>();
builder.Services.AddScoped<IProductCatalogLens, ProductCatalogLens>();
builder.Services.AddScoped<IInventoryLevelsLens, InventoryLevelsLens>();

// Register GraphQL mutations
builder.Services.AddScoped<SeedMutations>();

// Add HotChocolate GraphQL server with filtering/sorting/projection support
builder.Services
  .AddGraphQLServer()
  .AddQueryType<CatalogQueries>()
  .AddMutationType<SeedMutations>()  // Admin/dev seeding mutations
  .AddFiltering()  // Enable WHERE clauses
  .AddSorting()    // Enable ORDER BY clauses
  .AddProjections();  // Enable field selection optimization

// Register transport readiness check (ServiceBusReadinessCheck for Azure Service Bus)
builder.Services.AddSingleton<ITransportReadinessCheck>(sp => {
  var transport = sp.GetRequiredService<ITransport>();
  var client = sp.GetRequiredService<Azure.Messaging.ServiceBus.ServiceBusClient>();
  var logger = sp.GetRequiredService<ILogger<Whizbang.Hosting.Azure.ServiceBus.ServiceBusReadinessCheck>>();
  return new Whizbang.Hosting.Azure.ServiceBus.ServiceBusReadinessCheck(transport, client, logger);
});

// Register IMessagePublishStrategy for WorkCoordinatorPublisherWorker
builder.Services.AddSingleton<IMessagePublishStrategy>(sp =>
  new TransportPublishStrategy(
    sp.GetRequiredService<ITransport>(),
    sp.GetRequiredService<ITransportReadinessCheck>()
  )
);

// Service Bus consumer - receives events from all services
// Perspectives are invoked automatically via PerspectiveInvoker
// NOTE: Subscription names must be unique across all topics in Aspire AppHost model
var consumerOptions = new ServiceBusConsumerOptions();
consumerOptions.Subscriptions.Add(new TopicSubscription("products", "sub-bff-products"));
consumerOptions.Subscriptions.Add(new TopicSubscription("orders", "sub-bff-orders"));
consumerOptions.Subscriptions.Add(new TopicSubscription("payments", "sub-bff-payments"));
consumerOptions.Subscriptions.Add(new TopicSubscription("shipping", "sub-bff-shipping"));
builder.Services.AddSingleton(consumerOptions);
builder.Services.AddHostedService<ServiceBusConsumerWorker>(sp =>
  new ServiceBusConsumerWorker(
    sp.GetRequiredService<IServiceInstanceProvider>(),
    sp.GetRequiredService<ITransport>(),
    sp.GetRequiredService<IServiceScopeFactory>(),
    sp.GetRequiredService<JsonSerializerOptions>(),
    sp.GetRequiredService<ILogger<ServiceBusConsumerWorker>>(),
    sp.GetRequiredService<OrderedStreamProcessor>(),
    consumerOptions
  )
);

// Outbox publisher worker - publishes pending messages from outbox to Service Bus
// Options configured via appsettings.json "WorkCoordinatorPublisher" section
builder.Services.AddHostedService<WorkCoordinatorPublisherWorker>();

// Configure PerspectiveWorkerOptions from appsettings.json
builder.Services.AddOptions<PerspectiveWorkerOptions>()
  .Bind(builder.Configuration.GetSection("PerspectiveWorker"));

// Perspective worker - processes perspective checkpoints (event replay for read models)
// NOTE: Skeleton implementation - logs checkpoint claims but doesn't invoke perspectives yet
builder.Services.AddHostedService<PerspectiveWorker>();

// Add FastEndpoints for REST API (AOT-compatible)
builder.Services.AddFastEndpoints();
builder.Services.SwaggerDocument();

// Add SignalR for real-time client updates (AOT-compatible with typed hub)
builder.Services.AddSignalR()
  .AddJsonProtocol(options => {
    // Use global registry for AOT compatibility (includes all registered contexts)
    options.PayloadSerializerOptions = Whizbang.Core.Serialization.JsonContextRegistry.CreateCombinedOptions();
  });

// Add CORS for Angular - uses Aspire service discovery to get Angular URL
builder.Services.AddCors(options => {
  options.AddDefaultPolicy(policy => {
    policy.WithOrigins(angularUrl)  // Angular URL from Aspire service discovery
      .AllowAnyHeader()
      .AllowAnyMethod()
      .AllowCredentials();  // Required for SignalR
  });
});

var app = builder.Build();

// Log discovered Angular URL for debugging
app.Logger.LogInformation("CORS configured for Angular UI at: {AngularUrl}", angularUrl);

// Initialize database schema on startup
// Uses generated EnsureWhizbangDatabaseInitializedAsync() extension method
// Creates all PerspectiveRow<T> entities + Inbox/Outbox/EventStore tables + PostgreSQL functions
using (var scope = app.Services.CreateScope()) {
  var dbContext = scope.ServiceProvider.GetRequiredService<BffDbContext>();
  var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();
  await dbContext.EnsureWhizbangDatabaseInitializedAsync(logger);
}

// Development-only: Auto-seed products on startup
// In production, admin manually triggers SeedProducts GraphQL mutation
#if DEBUG
if (app.Environment.IsDevelopment()) {
  using (var scope = app.Services.CreateScope()) {
    var seedMutations = scope.ServiceProvider.GetRequiredService<SeedMutations>();
    try {
      var seededCount = await seedMutations.SeedProducts();
      if (seededCount > 0) {
        app.Logger.LogInformation("Development seeding: {Count} products seeded", seededCount);
      }
    } catch (Exception ex) {
      app.Logger.LogWarning(ex, "Development seeding failed - continuing anyway");
    }
  }
}
#endif

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment()) {
  app.UseDeveloperExceptionPage();
  app.UseSwaggerGen(); // FastEndpoints Swagger UI
}

app.UseHttpsRedirection();

// Enable CORS before other middleware
app.UseCors();

// FastEndpoints (REST API)
app.UseFastEndpoints(config => {
  config.Endpoints.RoutePrefix = "api";
});

// Map SignalR hubs
app.MapHub<OrderStatusHub>("/hubs/order-status");
app.MapHub<ProductInventoryHub>("/hubs/product-inventory");

// Map GraphQL endpoint with Banana Cake Pop UI (GraphQL IDE)
app.MapGraphQL("/graphql");

// Aspire health checks and diagnostics
app.MapDefaultEndpoints();

app.Run();
