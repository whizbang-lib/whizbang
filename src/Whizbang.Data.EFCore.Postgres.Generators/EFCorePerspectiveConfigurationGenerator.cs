using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Whizbang.Data.EFCore.Postgres.Generators;

/// <summary>
/// Source generator that discovers perspectives and generates EF Core ModelBuilder configuration.
/// Generates a ConfigureWhizbangPerspectives() extension method for ModelBuilder.
/// </summary>
[Generator]
public class EFCorePerspectiveConfigurationGenerator : IIncrementalGenerator {
  private const string PERSPECTIVE_INTERFACE = "Whizbang.Core.IPerspectiveOf";

  public void Initialize(IncrementalGeneratorInitializationContext context) {
    // Discover all classes that implement IPerspectiveOf<TEvent>
    var perspectives = context.SyntaxProvider.CreateSyntaxProvider(
        predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
        transform: static (ctx, ct) => ExtractPerspectiveInfo(ctx, ct)
    ).Where(static info => info is not null);

    // Generate ModelBuilder extension method
    context.RegisterSourceOutput(
        perspectives.Collect(),
        static (ctx, perspectives) => GenerateModelBuilderExtension(ctx, perspectives!)
    );
  }

  /// <summary>
  /// Extracts perspective information from a class declaration.
  /// Returns null if the class doesn't implement IPerspectiveOf.
  /// </summary>
  private static PerspectiveInfo? ExtractPerspectiveInfo(
      GeneratorSyntaxContext context,
      CancellationToken ct) {

    var classDecl = (ClassDeclarationSyntax)context.Node;
    var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl, ct) as INamedTypeSymbol;

    if (symbol is null) {
      return null;
    }

    // Find IPerspectiveOf<TEvent> interface
    var perspectiveInterface = symbol.AllInterfaces.FirstOrDefault(i =>
        i.IsGenericType &&
        i.ConstructedFrom.ToDisplayString() == PERSPECTIVE_INTERFACE);

    if (perspectiveInterface is null) {
      return null;
    }

    // Get the event type (TEvent from IPerspectiveOf<TEvent>)
    var eventType = perspectiveInterface.TypeArguments[0];

    // Get the model type from the perspective's Model property
    // Assumption: Perspectives have a property that returns the model type
    // For now, we'll infer from the class name by convention
    // E.g., "OrderPerspective" -> "OrderSummary" (remove "Perspective" suffix)
    var className = symbol.Name;
    var modelTypeName = InferModelTypeName(symbol);

    if (modelTypeName is null) {
      return null;
    }

    // Generate table name from model type name (e.g., "OrderSummary" -> "order_summary")
    var tableName = ToSnakeCase(modelTypeName);

    return new PerspectiveInfo(
        ModelTypeName: $"global::{modelTypeName}",
        TableName: tableName
    );
  }

  /// <summary>
  /// Infers the model type name from the perspective class.
  /// Looks for properties or methods that return the model type.
  /// </summary>
  private static string? InferModelTypeName(INamedTypeSymbol perspectiveSymbol) {
    // Look for a property or method that returns a type (the model)
    // Common patterns:
    // 1. A property with a specific type
    // 2. UpdateAsync method parameter type
    // 3. Convention: Remove "Perspective" suffix from class name

    // For now, use convention: Remove "Perspective" suffix
    var className = perspectiveSymbol.Name;
    if (className.EndsWith("Perspective")) {
      var modelName = className.Substring(0, className.Length - "Perspective".Length);

      // Get the containing namespace
      var ns = perspectiveSymbol.ContainingNamespace;
      if (ns is not null && !ns.IsGlobalNamespace) {
        return $"{ns.ToDisplayString()}.{modelName}";
      }

      return modelName;
    }

    return null;
  }

  /// <summary>
  /// Converts PascalCase to snake_case.
  /// </summary>
  private static string ToSnakeCase(string input) {
    if (string.IsNullOrEmpty(input)) {
      return input;
    }

    var sb = new StringBuilder();
    sb.Append(char.ToLowerInvariant(input[0]));

    for (int i = 1; i < input.Length; i++) {
      char c = input[i];
      if (char.IsUpper(c)) {
        sb.Append('_');
        sb.Append(char.ToLowerInvariant(c));
      } else {
        sb.Append(c);
      }
    }

    return sb.ToString();
  }

  /// <summary>
  /// Generates the ModelBuilder extension method with EF Core configuration.
  /// </summary>
  private static void GenerateModelBuilderExtension(
      SourceProductionContext context,
      ImmutableArray<PerspectiveInfo> perspectives) {

    if (perspectives.IsEmpty) {
      return; // No perspectives found, nothing to generate
    }

    var sb = new StringBuilder();

    // File header
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine($"// Generated by Whizbang.Data.EFCore.Postgres.Generators at {System.DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
    sb.AppendLine("// DO NOT EDIT - Changes will be overwritten");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();

    sb.AppendLine("using Microsoft.EntityFrameworkCore;");
    sb.AppendLine("using Whizbang.Core.Lenses;");
    sb.AppendLine();

    sb.AppendLine("namespace Whizbang.Data.EFCore.Postgres;");
    sb.AppendLine();

    // Extension class
    sb.AppendLine("/// <summary>");
    sb.AppendLine("/// Extension methods for configuring Whizbang perspectives in EF Core ModelBuilder.");
    sb.AppendLine("/// </summary>");
    sb.AppendLine("public static class WhizbangModelBuilderExtensions {");
    sb.AppendLine();

    // Extension method
    sb.AppendLine("  /// <summary>");
    sb.AppendLine("  /// Configures all Whizbang perspectives for PostgreSQL with JSONB columns.");
    sb.AppendLine("  /// </summary>");
    sb.AppendLine("  /// <param name=\"modelBuilder\">The ModelBuilder instance</param>");
    sb.AppendLine("  /// <returns>The ModelBuilder instance for chaining</returns>");
    sb.AppendLine("  public static ModelBuilder ConfigureWhizbangPerspectives(this ModelBuilder modelBuilder) {");
    sb.AppendLine();

    // Configure each perspective
    foreach (var perspective in perspectives) {
      sb.AppendLine($"    // Configure {perspective.ModelTypeName}");
      sb.AppendLine($"    modelBuilder.Entity<PerspectiveRow<{perspective.ModelTypeName}>>(entity => {{");
      sb.AppendLine($"      entity.ToTable(\"{perspective.TableName}\");");
      sb.AppendLine("      entity.HasKey(e => e.Id);");
      sb.AppendLine();
      sb.AppendLine("      // Configure JSONB columns using EF Core 10 complex types");
      sb.AppendLine("      entity.ComplexProperty(e => e.Data).ToJson(\"model_data\");");
      sb.AppendLine("      entity.ComplexProperty(e => e.Metadata).ToJson(\"metadata\");");
      sb.AppendLine("      entity.ComplexProperty(e => e.Scope).ToJson(\"scope\");");
      sb.AppendLine();
      sb.AppendLine("      // Configure system fields");
      sb.AppendLine("      entity.Property(e => e.CreatedAt).IsRequired();");
      sb.AppendLine("      entity.Property(e => e.UpdatedAt).IsRequired();");
      sb.AppendLine("      entity.Property(e => e.Version).IsRequired();");
      sb.AppendLine("    });");
      sb.AppendLine();
    }

    sb.AppendLine("    return modelBuilder;");
    sb.AppendLine("  }");
    sb.AppendLine("}");

    context.AddSource("WhizbangModelBuilderExtensions.g.cs", sb.ToString());
  }
}
