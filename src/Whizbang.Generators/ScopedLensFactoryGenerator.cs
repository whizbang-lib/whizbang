using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Whizbang.Generators;

/// <summary>
/// Source generator that discovers lens types implementing ILensQuery&lt;TModel&gt;
/// and generates a LensRegistry for AOT-compatible lens discovery.
/// </summary>
[Generator]
public class ScopedLensFactoryGenerator : IIncrementalGenerator {
  private const string LENS_QUERY_INTERFACE_NAME = "ILensQuery";
  private const string LENS_QUERY_NAMESPACE = "Whizbang.Core.Lenses";

  public void Initialize(IncrementalGeneratorInitializationContext context) {
    // Discover types implementing ILensQuery<TModel>
    var lensTypes = context.SyntaxProvider.CreateSyntaxProvider(
        predicate: static (node, _) => node is TypeDeclarationSyntax { BaseList.Types.Count: > 0 },
        transform: static (ctx, ct) => _extractLensInfo(ctx, ct)
    ).Where(static info => info is not null);

    // Generate registry
    context.RegisterSourceOutput(
        lensTypes.Collect(),
        static (ctx, lenses) => _generateRegistry(ctx, lenses!)
    );
  }

  private static LensInfo? _extractLensInfo(
      GeneratorSyntaxContext context,
      CancellationToken ct) {

    var typeDecl = (TypeDeclarationSyntax)context.Node;
    var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDecl, ct);

    if (typeSymbol is null) {
      return null;
    }

    // Only process public types to avoid discovering test types
    if (typeSymbol.DeclaredAccessibility != Accessibility.Public) {
      return null;
    }

    // Find ILensQuery<TModel> interface - check by name and namespace
    var lensInterface = typeSymbol.AllInterfaces
        .FirstOrDefault(i =>
            i.IsGenericType &&
            i.OriginalDefinition.Name == LENS_QUERY_INTERFACE_NAME &&
            i.OriginalDefinition.ContainingNamespace?.ToDisplayString() == LENS_QUERY_NAMESPACE);

    if (lensInterface is null) {
      return null;
    }

    // Get the model type argument
    if (lensInterface.TypeArguments.Length != 1) {
      return null;
    }

    var modelType = lensInterface.TypeArguments[0];
    var modelFullName = modelType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    var lensFullName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

    // Detect scope properties on the model
    var scopeProperties = _detectScopeProperties(modelType);

    // Check if model implements common scoping interfaces
    var implementsTenantScoped = _implementsInterface(modelType, "ITenantScoped");
    var implementsUserScoped = _implementsInterface(modelType, "IUserScoped");

    return new LensInfo(
        LensTypeName: lensFullName,
        LensTypeShortName: typeSymbol.Name,
        IsInterface: typeSymbol.TypeKind == TypeKind.Interface,
        ModelTypeName: modelFullName,
        ModelTypeShortName: modelType.Name,
        ScopeProperties: scopeProperties,
        ImplementsTenantScoped: implementsTenantScoped,
        ImplementsUserScoped: implementsUserScoped
    );
  }

  private static bool _implementsInterface(ITypeSymbol type, string interfaceName) {
    return type.AllInterfaces.Any(i => i.Name == interfaceName);
  }

  private static string[] _detectScopeProperties(ITypeSymbol modelType) {
    var scopePropertyNames = new[] { "TenantId", "UserId", "OrganizationId", "ScopeId" };

    return modelType.GetMembers()
        .OfType<IPropertySymbol>()
        .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
        .Where(p => scopePropertyNames.Contains(p.Name))
        .Select(p => p.Name)
        .ToArray();
  }

  private static void _generateRegistry(
      SourceProductionContext context,
      ImmutableArray<LensInfo?> lenses) {

    var validLenses = lenses.Where(l => l is not null).Select(l => l!).ToList();

    var sb = new StringBuilder();
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("using System;");
    sb.AppendLine("using System.Collections.Generic;");
    sb.AppendLine("using Whizbang.Core.Lenses;");
    sb.AppendLine();
    sb.AppendLine("namespace Whizbang.Core.Generated;");
    sb.AppendLine();
    sb.AppendLine("/// <summary>");
    sb.AppendLine("/// Auto-generated registry of lens types implementing ILensQuery.");
    sb.AppendLine("/// Provides AOT-compatible lens discovery and scope property information.");
    sb.AppendLine("/// </summary>");
    sb.AppendLine("file static class LensRegistry {");
    sb.AppendLine("  /// <summary>");
    sb.AppendLine("  /// All registered lens entries.");
    sb.AppendLine("  /// </summary>");
    sb.AppendLine("  public static IReadOnlyList<LensRegistration> Lenses { get; } = new LensRegistration[] {");

    foreach (var lens in validLenses) {
      _generateRegistration(sb, lens);
    }

    sb.AppendLine("  };");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>");
    sb.AppendLine("  /// Gets registration for a specific lens type.");
    sb.AppendLine("  /// </summary>");
    sb.AppendLine("  public static LensRegistration? GetRegistrationFor(Type lensType) {");
    sb.AppendLine("    foreach (var lens in Lenses) {");
    sb.AppendLine("      if (lens.LensType == lensType) {");
    sb.AppendLine("        return lens;");
    sb.AppendLine("      }");
    sb.AppendLine("    }");
    sb.AppendLine("    return null;");
    sb.AppendLine("  }");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>");
    sb.AppendLine("  /// Gets registration for a specific lens type.");
    sb.AppendLine("  /// </summary>");
    sb.AppendLine("  public static LensRegistration? GetRegistrationFor<TLens>() where TLens : ILensQuery");
    sb.AppendLine("    => GetRegistrationFor(typeof(TLens));");
    sb.AppendLine("}");
    sb.AppendLine();
    sb.AppendLine("/// <summary>");
    sb.AppendLine("/// Registration entry for a lens type with scope information.");
    sb.AppendLine("/// </summary>");
    sb.AppendLine("file sealed record LensRegistration {");
    sb.AppendLine("  /// <summary>The lens type (interface or class).</summary>");
    sb.AppendLine("  public required Type LensType { get; init; }");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>The model type the lens queries.</summary>");
    sb.AppendLine("  public required Type ModelType { get; init; }");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>Whether the lens type is an interface.</summary>");
    sb.AppendLine("  public required bool IsInterface { get; init; }");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>Scope property names detected on the model (e.g., TenantId, UserId).</summary>");
    sb.AppendLine("  public required string[] ScopeProperties { get; init; }");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>Whether the model implements ITenantScoped.</summary>");
    sb.AppendLine("  public required bool ImplementsTenantScoped { get; init; }");
    sb.AppendLine();
    sb.AppendLine("  /// <summary>Whether the model implements IUserScoped.</summary>");
    sb.AppendLine("  public required bool ImplementsUserScoped { get; init; }");
    sb.AppendLine("}");

    context.AddSource("LensRegistry.g.cs", sb.ToString());
  }

  private static void _generateRegistration(StringBuilder sb, LensInfo lens) {
    sb.AppendLine($"    new LensRegistration {{");
    sb.AppendLine($"      LensType = typeof({lens.LensTypeName}),");
    sb.AppendLine($"      ModelType = typeof({lens.ModelTypeName}),");
    sb.AppendLine($"      IsInterface = {(lens.IsInterface ? "true" : "false")},");

    if (lens.ScopeProperties.Length > 0) {
      sb.AppendLine($"      ScopeProperties = new[] {{ {string.Join(", ", lens.ScopeProperties.Select(p => $"\"{p}\""))} }},");
    } else {
      sb.AppendLine("      ScopeProperties = Array.Empty<string>(),");
    }

    sb.AppendLine($"      ImplementsTenantScoped = {(lens.ImplementsTenantScoped ? "true" : "false")},");
    sb.AppendLine($"      ImplementsUserScoped = {(lens.ImplementsUserScoped ? "true" : "false")}");
    sb.AppendLine($"    }},");
  }
}

/// <summary>
/// Value type record for caching discovered lens information.
/// </summary>
internal sealed record LensInfo(
    string LensTypeName,
    string LensTypeShortName,
    bool IsInterface,
    string ModelTypeName,
    string ModelTypeShortName,
    string[] ScopeProperties,
    bool ImplementsTenantScoped,
    bool ImplementsUserScoped
);
