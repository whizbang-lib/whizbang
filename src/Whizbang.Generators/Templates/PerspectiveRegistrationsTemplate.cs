using System;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Whizbang.Core;
using Whizbang.Core.Perspectives;

#region NAMESPACE
namespace Whizbang.Core.Generated;
#endregion

#region HEADER
// This region gets replaced with generated header + timestamp
#endregion

/// <summary>
/// Represents a message-to-perspective association discovered during source generation.
/// Used for querying which perspectives handle which events.
/// </summary>
/// <param name="MessageType">Fully qualified message type name (e.g., "MyApp.Events.OrderCreated, MyApp")</param>
/// <param name="AssociationType">Association type (e.g., "perspective")</param>
/// <param name="TargetName">Name of the perspective (e.g., "OrderPerspective")</param>
/// <param name="ServiceName">Service name (assembly name)</param>
public sealed record MessageAssociation(
  string MessageType,
  string AssociationType,
  string TargetName,
  string ServiceName
);

/// <summary>
/// Extension methods for registering {{PERSPECTIVE_CLASS_COUNT}} discovered perspective(s) with {{REGISTRATION_COUNT}} event handler(s).
/// Perspectives are registered as Scoped services and updated via Event Store.
/// Generated by Whizbang.Generators.PerspectiveDiscoveryGenerator.
/// </summary>
public static class PerspectiveRegistrationExtensions {
  /// <summary>
  /// Registers all discovered IPerspectiveFor implementations with the service collection.
  /// Each perspective is registered as Scoped to match the typical database context lifetime.
  /// Returns a WhizbangPerspectiveBuilder for fluent configuration of storage providers.
  /// </summary>
  /// <param name="services">The service collection to add registrations to</param>
  /// <returns>A WhizbangPerspectiveBuilder for configuring storage providers</returns>
  public static WhizbangPerspectiveBuilder AddWhizbangPerspectives(this IServiceCollection services) {
    #region PERSPECTIVE_REGISTRATIONS
    // This region gets replaced with generated registration code
    #endregion

    return new WhizbangPerspectiveBuilder(services);
  }

  /// <summary>
  /// Registers perspective â†’ event type associations in the database.
  /// This enables the work coordinator to automatically create perspective checkpoints when events arrive.
  /// MUST be called during database initialization (after EnsureWhizbangDatabaseInitializedAsync).
  /// </summary>
  /// <param name="context">The DbContext instance</param>
  /// <param name="schema">The schema name for the database (e.g., "inventory", "bff")</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <param name="logger">Optional logger for diagnostic messages</param>
  /// <param name="cancellationToken">Cancellation token</param>
  public static async Task RegisterPerspectiveAssociationsAsync<TDbContext>(
    this TDbContext context,
    string schema,
    string serviceName,
    ILogger? logger = null,
    CancellationToken cancellationToken = default)
    where TDbContext : DbContext {

    // Build JSON array of message associations
    var json = new StringBuilder();
    json.AppendLine("[");

    #region MESSAGE_ASSOCIATIONS_JSON
    // This region gets replaced with generated association JSON
    #endregion

    json.AppendLine("]");

    var jsonString = json.ToString();

    logger?.LogInformation("Registering {Count} perspective message association(s) in schema '{Schema}'...", {{ASSOCIATION_COUNT}}, schema);

    // Call the schema-qualified register_message_associations function
    // Uses parameterized query to avoid SQL injection
    var sql = $@"
      SELECT {schema}.register_message_associations(@p0::jsonb)
    ";

    try {
      await context.Database.ExecuteSqlRawAsync(sql, new[] { jsonString }, cancellationToken);
      logger?.LogInformation("Successfully registered perspective message associations");
    } catch (Exception ex) {
      logger?.LogError(ex, "Failed to register perspective message associations in schema '{Schema}'", schema);
      throw;
    }
  }

  /// <summary>
  /// Gets all message associations for the specified service.
  /// Returns associations between event types and perspectives.
  /// </summary>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <returns>Read-only list of message associations</returns>
  public static System.Collections.Generic.IReadOnlyList<MessageAssociation> GetMessageAssociations(string serviceName) {
    #region MESSAGE_ASSOCIATIONS_ARRAY
    // This region gets replaced with generated association array
    #endregion
  }

  /// <summary>
  /// Gets all perspectives that handle the specified event type.
  /// </summary>
  /// <param name="eventType">Fully qualified event type name</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <returns>Enumerable of perspective names</returns>
  public static System.Collections.Generic.IEnumerable<string> GetPerspectivesForEvent(string eventType, string serviceName) {
    return GetMessageAssociations(serviceName)
      .Where(a => a.MessageType == eventType && a.AssociationType == "perspective")
      .Select(a => a.TargetName);
  }

  /// <summary>
  /// Gets all events handled by the specified perspective.
  /// </summary>
  /// <param name="perspectiveName">Name of the perspective</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <returns>Enumerable of event type names</returns>
  public static System.Collections.Generic.IEnumerable<string> GetEventsForPerspective(string perspectiveName, string serviceName) {
    return GetMessageAssociations(serviceName)
      .Where(a => a.TargetName == perspectiveName && a.AssociationType == "perspective")
      .Select(a => a.MessageType);
  }

  /// <summary>
  /// Gets all perspectives that handle the specified event type with fuzzy matching support.
  /// </summary>
  /// <param name="eventType">Event type name (can be simple, namespace-qualified, or fully-qualified)</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <param name="strictness">Flags controlling matching behavior (IgnoreCase, IgnoreVersion, IgnoreAssembly, IgnoreNamespace)</param>
  /// <returns>Enumerable of perspective names that handle events matching the specified type</returns>
  /// <remarks>
  /// This overload enables flexible type matching. Examples:
  /// - MatchStrictness.SimpleName: Match "ProductCreatedEvent" against any namespace
  /// - MatchStrictness.IgnoreCase: Case-insensitive matching
  /// - MatchStrictness.SimpleNameCaseInsensitive: Match simple name, case-insensitive
  /// Multiple flags can be combined using bitwise OR.
  /// </remarks>
  public static System.Collections.Generic.IEnumerable<string> GetPerspectivesForEvent(
      string eventType,
      string serviceName,
      MatchStrictness strictness) {
    return GetMessageAssociations(serviceName)
      .Where(a => a.AssociationType == "perspective" && TypeMatcher.Matches(a.MessageType, eventType, strictness))
      .Select(a => a.TargetName);
  }

  /// <summary>
  /// Gets all perspectives that handle events matching the specified regex pattern.
  /// </summary>
  /// <param name="eventPattern">Regex pattern to match event type names</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <returns>Enumerable of perspective names that handle events matching the pattern</returns>
  /// <remarks>
  /// This overload enables pattern-based matching. Examples:
  /// - new Regex(".*Product.*") : Match any event type containing "Product"
  /// - new Regex(".*Event$") : Match any event type ending with "Event"
  /// - new Regex("^ECommerce\..*") : Match any event type starting with "ECommerce."
  /// </remarks>
  public static System.Collections.Generic.IEnumerable<string> GetPerspectivesForEvent(
      Regex eventPattern,
      string serviceName) {
    return GetMessageAssociations(serviceName)
      .Where(a => a.AssociationType == "perspective" && TypeMatcher.Matches(a.MessageType, eventPattern))
      .Select(a => a.TargetName);
  }

  /// <summary>
  /// Gets all events handled by the specified perspective with fuzzy matching support.
  /// </summary>
  /// <param name="perspectiveName">Perspective name (can be simple or fully-qualified)</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <param name="strictness">Flags controlling matching behavior</param>
  /// <returns>Enumerable of event type names</returns>
  public static System.Collections.Generic.IEnumerable<string> GetEventsForPerspective(
      string perspectiveName,
      string serviceName,
      MatchStrictness strictness) {
    return GetMessageAssociations(serviceName)
      .Where(a => a.AssociationType == "perspective" && TypeMatcher.Matches(a.TargetName, perspectiveName, strictness))
      .Select(a => a.MessageType);
  }

  /// <summary>
  /// Gets all events for perspectives matching the specified regex pattern.
  /// </summary>
  /// <param name="perspectivePattern">Regex pattern to match perspective names</param>
  /// <param name="serviceName">The service name (assembly name)</param>
  /// <returns>Enumerable of event type names</returns>
  public static System.Collections.Generic.IEnumerable<string> GetEventsForPerspective(
      Regex perspectivePattern,
      string serviceName) {
    return GetMessageAssociations(serviceName)
      .Where(a => a.AssociationType == "perspective" && TypeMatcher.Matches(a.TargetName, perspectivePattern))
      .Select(a => a.MessageType);
  }
}
