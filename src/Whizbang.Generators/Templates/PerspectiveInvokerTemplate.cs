using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Whizbang.Core;
using Whizbang.Core.Perspectives;

#region NAMESPACE
namespace Whizbang.Core.Generated;
#endregion

#region HEADER
// Auto-generated by Whizbang source generator
#endregion

/// <summary>
/// Generated perspective invoker with AOT-compatible routing.
/// Queues events during a scope and invokes perspectives on disposal.
/// Thread-safe for concurrent event queueing.
/// </summary>
internal sealed class GeneratedPerspectiveInvoker : IPerspectiveInvoker {
  private readonly IServiceProvider _serviceProvider;
  private readonly List<IEvent> _queuedEvents = new();
  private readonly object _lock = new();
  private bool _disposed = false;

  public GeneratedPerspectiveInvoker(IServiceProvider serviceProvider) {
    _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
  }

  public void QueueEvent(IEvent @event) {
    if (@event == null) throw new ArgumentNullException(nameof(@event));

    lock (_lock) {
      if (_disposed) {
        throw new ObjectDisposedException(nameof(GeneratedPerspectiveInvoker));
      }
      _queuedEvents.Add(@event);
    }
  }

  public async Task InvokePerspectivesAsync(CancellationToken ct = default) {
    List<IEvent> eventsToProcess;

    lock (_lock) {
      if (_queuedEvents.Count == 0) return;
      eventsToProcess = new List<IEvent>(_queuedEvents);
      _queuedEvents.Clear();
    }

    // Invoke perspectives for each queued event
    foreach (var @event in eventsToProcess) {
      var publisher = _getPerspectivePublisher(@event, @event.GetType());
      if (publisher != null) {
        await publisher(@event);
      }
    }
  }

  private PerspectivePublisher? _getPerspectivePublisher(IEvent @event, Type eventType) {
    #region PERSPECTIVE_ROUTING
    // Generated routing code inserted here
    #endregion

    return null;  // No perspectives for this event type
  }

  public async ValueTask DisposeAsync() {
    if (!_disposed) {
      _disposed = true;
      await InvokePerspectivesAsync();
    }
  }
}

/// <summary>
/// Delegate for publishing an event to perspectives.
/// </summary>
internal delegate Task PerspectivePublisher(IEvent @event);
