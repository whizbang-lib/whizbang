#region HEADER
// <auto-generated/>
// Generated at: __TIMESTAMP__
#endregion
#nullable enable

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Whizbang.Core;
using Whizbang.Core.Data;
using Whizbang.Core.Messaging;
using Whizbang.Core.Observability;
using Whizbang.Core.Perspectives;
using Whizbang.Core.Transports;

#region NAMESPACE
namespace Whizbang.Core.Generated {
#endregion
  /// <summary>
  /// Auto-generated registrations for receptors, dispatcher, and perspective invoker.
  /// </summary>
  [ExcludeFromCodeCoverage]
  [DebuggerNonUserCode]
  public static class DispatcherRegistrations {
    /// <summary>
    /// Registers all {{RECEPTOR_COUNT}} discovered receptors with the service collection.
    /// </summary>
    [ExcludeFromCodeCoverage]
    [DebuggerNonUserCode]
    public static IServiceCollection AddReceptors(this IServiceCollection services) {
      #region RECEPTOR_REGISTRATIONS
      // This region will be replaced with receptor registration calls
      #endregion
      return services;
    }

    /// <summary>
    /// Registers the generated IPerspectiveInvoker as a Scoped service.
    /// One instance per HTTP request or message batch for proper unit of work scoping.
    /// </summary>
    [ExcludeFromCodeCoverage]
    [DebuggerNonUserCode]
    public static IServiceCollection AddWhizbangPerspectiveInvoker(this IServiceCollection services) {
      services.AddScoped<IPerspectiveInvoker, GeneratedPerspectiveInvoker>();
      return services;
    }

    /// <summary>
    /// Registers the generated zero-reflection dispatcher.
    /// Automatically resolves optional Singleton dependencies: ITraceStore, ITransport, JsonSerializerOptions, ITopicRegistry, ITopicRoutingStrategy, IAggregateIdExtractor.
    /// NOTE: IEventStore and IWorkCoordinatorStrategy are resolved per-call from the active scope, not captured in constructor.
    /// This is required because they may be registered as Scoped (e.g., EF Core implementations).
    /// </summary>
    [ExcludeFromCodeCoverage]
    [DebuggerNonUserCode]
    public static IServiceCollection AddWhizbangDispatcher(this IServiceCollection services) {
      services.AddSingleton<IDispatcher>(sp => {
        var instanceProvider = sp.GetRequiredService<IServiceInstanceProvider>();
        var traceStore = sp.GetService<ITraceStore>();
        var transport = sp.GetService<ITransport>();
        var jsonOptions = sp.GetService<JsonSerializerOptions>();
        var topicRegistry = sp.GetService<Whizbang.Core.Routing.ITopicRegistry>();
        var topicRoutingStrategy = sp.GetService<Whizbang.Core.Routing.ITopicRoutingStrategy>();
        var aggregateIdExtractor = sp.GetService<IAggregateIdExtractor>();
        var lifecycleInvoker = sp.GetService<ILifecycleInvoker>();

        // Do NOT resolve IEventStore or IWorkCoordinatorStrategy here - they may be Scoped
        // The Dispatcher will resolve them per-call from the active service provider
        return new GeneratedDispatcher(sp, instanceProvider, traceStore, transport, jsonOptions, topicRegistry, topicRoutingStrategy, aggregateIdExtractor, lifecycleInvoker);
      });
      services.AddSingleton<global::Whizbang.Core.Dispatcher>(sp => (GeneratedDispatcher)sp.GetRequiredService<IDispatcher>());
      return services;
    }

    /// <summary>
    /// Registers the generated zero-reflection lifecycle invoker.
    /// Stateless routing component registered as Singleton for optimal performance.
    /// Routes lifecycle invocations based on message type and lifecycle stage from [FireAt] attributes.
    /// </summary>
    [ExcludeFromCodeCoverage]
    [DebuggerNonUserCode]
    public static IServiceCollection AddWhizbangLifecycleInvoker(this IServiceCollection services) {
      services.AddSingleton<ILifecycleInvoker, GeneratedLifecycleInvoker>();
      return services;
    }

    /// <summary>
    /// Registers the lifecycle message deserializer for reconstructing messages at Distribute/Outbox/Inbox stages.
    /// Deserializes messages from JsonElement payloads in OutboxMessage/InboxMessage records.
    /// Registered as Singleton since it's stateless (JsonSerializerOptions resolved from DI).
    /// </summary>
    [ExcludeFromCodeCoverage]
    [DebuggerNonUserCode]
    public static IServiceCollection AddWhizbangLifecycleMessageDeserializer(this IServiceCollection services) {
      services.AddSingleton<ILifecycleMessageDeserializer>(sp => {
        var jsonOptions = sp.GetService<JsonSerializerOptions>();
        return new JsonLifecycleMessageDeserializer(jsonOptions);
      });
      return services;
    }
  }
}
