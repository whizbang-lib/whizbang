#region HEADER
// <auto-generated/>
// Generated at: __TIMESTAMP__
#endregion
#nullable enable

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Whizbang.Core;
using Whizbang.Core.Messaging;

#region NAMESPACE
namespace Whizbang.Core.Generated;
#endregion

/// <summary>
/// Generated ILifecycleInvoker implementation with zero-reflection routing for {{RECEPTOR_COUNT}} receptor(s).
/// Routes lifecycle invocations based on message type and lifecycle stage discovered from [FireAt] attributes.
/// Also checks ILifecycleReceptorRegistry for runtime-registered receptors.
/// </summary>
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class GeneratedLifecycleInvoker : global::Whizbang.Core.Messaging.ILifecycleInvoker {
  private readonly IServiceProvider _serviceProvider;

  public GeneratedLifecycleInvoker(IServiceProvider serviceProvider) {
    _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
  }

  /// <summary>
  /// Invokes all receptors registered for the given message type and lifecycle stage.
  /// Includes both compile-time discovered receptors (via [FireAt] attributes) and
  /// runtime registered receptors (via ILifecycleReceptorRegistry).
  /// </summary>
  [DebuggerStepThrough]
  public async ValueTask InvokeAsync(
      object message,
      LifecycleStage stage,
      ILifecycleContext? context = null,
      CancellationToken cancellationToken = default) {

    if (message is null) {
      throw new ArgumentNullException(nameof(message));
    }

    var messageType = message.GetType();

    // Generated compile-time routing based on [FireAt] attributes
    #region LIFECYCLE_ROUTING
    // This region will be replaced with generated lifecycle routing code
    #endregion

    // Check for runtime-registered receptors
    var registry = _serviceProvider.GetService<ILifecycleReceptorRegistry>();
    if (registry is not null) {
      var dynamicReceptors = registry.GetReceptors(messageType, stage);
      foreach (var receptor in dynamicReceptors) {
        await _invokeReceptorAsync(receptor, message, cancellationToken);
      }
    }
  }

  /// <summary>
  /// Invokes a dynamically registered receptor.
  /// Determines if receptor is IReceptor&lt;TMessage&gt; or IReceptor&lt;TMessage, TResponse&gt; and invokes appropriately.
  /// </summary>
  private static async ValueTask _invokeReceptorAsync(
      object receptor,
      object message,
      CancellationToken cancellationToken) {

    // Try to invoke as void receptor first (IReceptor<TMessage>)
    var receptorType = receptor.GetType();
    var voidInterface = Array.Find(
        receptorType.GetInterfaces(),
        i => i.IsGenericType &&
             i.GetGenericTypeDefinition().FullName == "Whizbang.Core.IReceptor`1"
    );

    if (voidInterface is not null) {
      var handleMethod = voidInterface.GetMethod("HandleAsync");
      if (handleMethod is not null) {
        var task = handleMethod.Invoke(receptor, new[] { message, cancellationToken });
        if (task is ValueTask valueTask) {
          await valueTask;
          return;
        }
      }
    }

    // Try to invoke as receptor with response (IReceptor<TMessage, TResponse>)
    var responseInterface = Array.Find(
        receptorType.GetInterfaces(),
        i => i.IsGenericType &&
             i.GetGenericTypeDefinition().FullName == "Whizbang.Core.IReceptor`2"
    );

    if (responseInterface is not null) {
      var handleMethod = responseInterface.GetMethod("HandleAsync");
      if (handleMethod is not null) {
        var task = handleMethod.Invoke(receptor, new[] { message, cancellationToken });
        if (task is ValueTask valueTask) {
          await valueTask;
        }
      }
    }
  }
}
