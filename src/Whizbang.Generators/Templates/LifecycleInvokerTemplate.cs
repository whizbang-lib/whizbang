#region HEADER
// <auto-generated/>
// Generated at: __TIMESTAMP__
#endregion
#nullable enable

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Whizbang.Core;
using Whizbang.Core.Messaging;

#region NAMESPACE
namespace Whizbang.Core.Generated;
#endregion

/// <summary>
/// Generated ILifecycleInvoker implementation with zero-reflection routing for {{RECEPTOR_COUNT}} receptor(s).
/// Routes lifecycle invocations based on message type and lifecycle stage discovered from [FireAt] attributes.
/// Also checks ILifecycleReceptorRegistry for runtime-registered receptors.
/// </summary>
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class GeneratedLifecycleInvoker : global::Whizbang.Core.Messaging.ILifecycleInvoker {
  private readonly IServiceProvider _serviceProvider;

  public GeneratedLifecycleInvoker(IServiceProvider serviceProvider) {
    _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
  }

  /// <summary>
  /// Invokes all receptors registered for the given message type and lifecycle stage.
  /// Includes both compile-time discovered receptors (via [FireAt] attributes) and
  /// runtime registered receptors (via ILifecycleReceptorRegistry).
  /// </summary>
  [DebuggerStepThrough]
  public async ValueTask InvokeAsync(
      object message,
      LifecycleStage stage,
      ILifecycleContext? context = null,
      CancellationToken cancellationToken = default) {

    if (message is null) {
      throw new ArgumentNullException(nameof(message));
    }

    var messageType = message.GetType();

    // Generated compile-time routing based on [FireAt] attributes
    #region LIFECYCLE_ROUTING
    // This region will be replaced with generated lifecycle routing code
    #endregion

    // Check for runtime-registered receptors (AOT-compatible via delegates)
    var registry = _serviceProvider.GetService<ILifecycleReceptorRegistry>();
    if (registry is not null) {
      var handlers = registry.GetHandlers(messageType, stage);
      foreach (var handler in handlers) {
        await handler(message, cancellationToken);
      }
    }
  }
}
