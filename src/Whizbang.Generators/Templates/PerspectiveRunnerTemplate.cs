using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Whizbang.Core;
using Whizbang.Core.Messaging;
using Whizbang.Core.Perspectives;

#region NAMESPACE
namespace Whizbang.Core.Generated;
#endregion

#region HEADER
// Auto-generated by Whizbang source generator
#endregion

/// <summary>
/// Generated perspective runner for __PERSPECTIVE_SIMPLE_NAME__.
/// Implements unit-of-work pattern with UUID7 event ordering and pure function event application.
/// </summary>
/// <remarks>
/// Unit of Work Pattern with Pure Functions:
/// - Reads events in UUID7 order (time-ordered)
/// - Applies ALL events to in-memory model using pure Apply() functions
/// - Pure functions: synchronous, deterministic, no I/O or side effects
/// - Saves model + checkpoint ONCE at batch boundary/failure/end
/// - On failure: saves checkpoint at last successful event
///
/// This ensures:
/// - Deterministic replay (pure functions guarantee same result)
/// - Atomic writes (model + checkpoint saved together)
/// - Partial progress on failure (checkpoint up to last success)
/// - No inline saves during event processing
/// - Compile-time purity enforcement via Roslyn analyzer
/// </remarks>
internal sealed class __RUNNER_CLASS_NAME__ : IPerspectiveRunner {
  private readonly IServiceProvider _serviceProvider;
  private readonly ILogger<__RUNNER_CLASS_NAME__> _logger;
  private readonly IEventStore _eventStore;
  private readonly IPerspectiveStore<__MODEL_TYPE_NAME__> _perspectiveStore;

  public __RUNNER_CLASS_NAME__(
      IServiceProvider serviceProvider,
      ILogger<__RUNNER_CLASS_NAME__> logger,
      IEventStore eventStore,
      IPerspectiveStore<__MODEL_TYPE_NAME__> perspectiveStore) {
    _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    _eventStore = eventStore ?? throw new ArgumentNullException(nameof(eventStore));
    _perspectiveStore = perspectiveStore ?? throw new ArgumentNullException(nameof(perspectiveStore));
  }

  public async Task<PerspectiveCheckpointCompletion> RunAsync(
      Guid streamId,
      string perspectiveName,
      Guid? lastProcessedEventId,
      CancellationToken cancellationToken = default) {

    // Load current model or create new one
    var currentModel = await _perspectiveStore.GetByStreamIdAsync(
        streamId,
        cancellationToken
    );

    // Create new model if none exists (null from DB)
    if (currentModel == null) {
      _logger.LogInformation(
          "No existing model found for stream {StreamId} in {PerspectiveName}, creating new model",
          streamId,
          perspectiveName
      );
      currentModel = CreateEmptyModel(streamId);
    }

    // Get perspective instance from DI
    var perspective = _serviceProvider.GetRequiredService<__PERSPECTIVE_CLASS_NAME__>();

    // Track progress
    var eventsProcessed = 0;
    var lastSuccessfulEventId = lastProcessedEventId;
    __MODEL_TYPE_NAME__ updatedModel = currentModel;

    try {
      // Read events in UUID7 order (time-ordered, no sequence numbers needed)
      await foreach (var envelope in _eventStore.ReadAsync<IEvent>(
          streamId,
          lastProcessedEventId,
          cancellationToken)) {

        // Extract event from envelope
        var @event = envelope.Payload;

        // Apply event to model using perspective's pure Apply method
        updatedModel = ApplyEvent(perspective, updatedModel, @event);

        // Track success
        lastSuccessfulEventId = envelope.MessageId.Value;
        eventsProcessed++;
      }

      // Unit of Work: Save model + checkpoint ONCE at end
      if (eventsProcessed > 0) {
        await SaveModelAndCheckpointAsync(
            streamId,
            updatedModel,
            lastSuccessfulEventId!.Value,
            cancellationToken
        );

        _logger.LogInformation(
            "Successfully processed {EventCount} events for {PerspectiveName} stream {StreamId}, checkpoint: {CheckpointEventId}",
            eventsProcessed,
            perspectiveName,
            streamId,
            lastSuccessfulEventId
        );
      }

      return new PerspectiveCheckpointCompletion {
        StreamId = streamId,
        PerspectiveName = perspectiveName,
        LastEventId = lastSuccessfulEventId ?? lastProcessedEventId ?? Guid.Empty,
        Status = eventsProcessed > 0 ? PerspectiveProcessingStatus.Completed : PerspectiveProcessingStatus.None
      };

    } catch (Exception ex) {
      // Partial success: save checkpoint up to last successful event
      if (lastSuccessfulEventId != null && lastSuccessfulEventId != lastProcessedEventId) {
        _logger.LogWarning(
            ex,
            "Error processing events for {PerspectiveName} stream {StreamId} after {EventCount} events. Saving partial progress to checkpoint {CheckpointEventId}",
            perspectiveName,
            streamId,
            eventsProcessed,
            lastSuccessfulEventId
        );

        try {
          await SaveModelAndCheckpointAsync(
              streamId,
              updatedModel,
              lastSuccessfulEventId.Value,
              cancellationToken
          );
        } catch (Exception saveEx) {
          _logger.LogError(
              saveEx,
              "Failed to save partial progress for {PerspectiveName} stream {StreamId}",
              perspectiveName,
              streamId
          );
          // Re-throw - we couldn't save partial progress
          throw;
        }
      } else {
        _logger.LogError(
            ex,
            "Error processing first event for {PerspectiveName} stream {StreamId}, no progress to save",
            perspectiveName,
            streamId
        );
      }

      // Re-throw - let PerspectiveWorker catch and convert to failure
      throw;
    }
  }

  /// <summary>
  /// Creates an empty model for a new stream.
  /// Initializes the model with the stream ID set to the stream key property.
  /// </summary>
  private __MODEL_TYPE_NAME__ CreateEmptyModel(Guid streamId) {
    // Create instance using default constructor or Activator
    var model = System.Activator.CreateInstance<__MODEL_TYPE_NAME__>();

    // Set the stream key property
    var streamKeyProperty = typeof(__MODEL_TYPE_NAME__).GetProperty("__STREAM_KEY_PROPERTY__");
    if (streamKeyProperty != null && streamKeyProperty.CanWrite) {
      streamKeyProperty.SetValue(model, streamId.ToString());
    }

    return model;
  }

  /// <summary>
  /// Applies an event to the model using the perspective's synchronous Apply method.
  /// AOT-compatible: uses switch statement instead of reflection.
  /// Apply methods are pure functions that return new model state.
  /// </summary>
  private __MODEL_TYPE_NAME__ ApplyEvent(
      __PERSPECTIVE_CLASS_NAME__ perspective,
      __MODEL_TYPE_NAME__ currentModel,
      IEvent @event) {

    // AOT-compatible switch on event type (no reflection)
    // Generator produces one case per event type the perspective handles
    switch (@event) {
      #region EVENT_APPLY_CASES
      // Generated switch cases go here
      #endregion

      default:
        throw new InvalidOperationException(
            $"Perspective {perspective.GetType().Name} does not handle event type {@event.GetType().Name}"
        );
    }
  }

  /// <summary>
  /// Saves the model and checkpoint atomically.
  /// This is the ONLY place where database writes occur (unit of work pattern).
  /// </summary>
  private async Task SaveModelAndCheckpointAsync(
      Guid streamId,
      __MODEL_TYPE_NAME__ model,
      Guid checkpointEventId,
      CancellationToken cancellationToken) {

    // Upsert model (insert or update)
    await _perspectiveStore.UpsertAsync(
        streamId,
        model,
        cancellationToken
    );

    // TODO: Save checkpoint
    // This will be implemented when we add checkpoint infrastructure
    // For now, the model save is atomic
  }
}
