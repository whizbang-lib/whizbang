using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Whizbang.Core;
using Whizbang.Core.Messaging;
using Whizbang.Core.Perspectives;

#region NAMESPACE
namespace Whizbang.Core.Generated;
#endregion

#region HEADER
// Auto-generated by Whizbang source generator
#endregion

/// <summary>
/// Generated perspective runner for __PERSPECTIVE_SIMPLE_NAME__.
/// Implements unit-of-work pattern with UUID7 event ordering and pure function event application.
/// </summary>
/// <remarks>
/// Unit of Work Pattern with Pure Functions:
/// - Reads events in UUID7 order (time-ordered)
/// - Applies ALL events to in-memory model using pure Apply() functions
/// - Pure functions: synchronous, deterministic, no I/O or side effects
/// - Saves model + checkpoint ONCE at batch boundary/failure/end
/// - On failure: saves checkpoint at last successful event
///
/// This ensures:
/// - Deterministic replay (pure functions guarantee same result)
/// - Atomic writes (model + checkpoint saved together)
/// - Partial progress on failure (checkpoint up to last success)
/// - No inline saves during event processing
/// - Compile-time purity enforcement via Roslyn analyzer
/// </remarks>
internal sealed class __RUNNER_CLASS_NAME__ : IPerspectiveRunner {
  private readonly IServiceProvider _serviceProvider;
  private readonly ILogger<__RUNNER_CLASS_NAME__> _logger;
  private readonly IEventStore _eventStore;
  private readonly IPerspectiveStore<__MODEL_TYPE_NAME__> _perspectiveStore;
  private readonly ILifecycleInvoker _lifecycleInvoker;

  public __RUNNER_CLASS_NAME__(
      IServiceProvider serviceProvider,
      ILogger<__RUNNER_CLASS_NAME__> logger,
      IEventStore eventStore,
      IPerspectiveStore<__MODEL_TYPE_NAME__> perspectiveStore,
      ILifecycleInvoker lifecycleInvoker) {
    _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    _eventStore = eventStore ?? throw new ArgumentNullException(nameof(eventStore));
    _perspectiveStore = perspectiveStore ?? throw new ArgumentNullException(nameof(perspectiveStore));
    _lifecycleInvoker = lifecycleInvoker ?? throw new ArgumentNullException(nameof(lifecycleInvoker));
  }

  public async Task<PerspectiveCheckpointCompletion> RunAsync(
      Guid streamId,
      string perspectiveName,
      Guid? lastProcessedEventId,
      CancellationToken cancellationToken = default) {

    // Load current model or create new one
    var currentModel = await _perspectiveStore.GetByStreamIdAsync(
        streamId,
        cancellationToken
    );

    // Create new model if none exists (null from DB)
    if (currentModel == null) {
      _logger.LogInformation(
          "No existing model found for stream {StreamId} in {PerspectiveName}, creating new model",
          streamId,
          perspectiveName
      );
      currentModel = CreateEmptyModel(streamId);
    }

    // Get perspective instance from DI
    var perspective = _serviceProvider.GetRequiredService<__PERSPECTIVE_CLASS_NAME__>();

    // Track progress
    var eventsProcessed = 0;
    var lastSuccessfulEventId = lastProcessedEventId;
    var processedEvents = new List<(object Event, Guid EventId)>();  // Track events for PostPerspectiveInline (fires AFTER save)
    var backgroundTasks = new List<Task>();  // Track async lifecycle tasks to ensure they complete
    __MODEL_TYPE_NAME__ updatedModel = currentModel;

    // Build list of event types this perspective handles (for polymorphic deserialization)
    var eventTypes = new[] {
      #region EVENT_TYPES
      // Generated event type list goes here
      #endregion
    };

    try {
      // Materialize events into list for PrePerspective peek and main processing
      // This allows PrePerspective receptors to receive the first event for type-based routing
      var events = new System.Collections.Generic.List<Whizbang.Core.Observability.MessageEnvelope<Whizbang.Core.IEvent>>();
      await foreach (var envelope in _eventStore.ReadPolymorphicAsync(
          streamId,
          lastProcessedEventId,
          eventTypes,
          cancellationToken)) {

        events.Add(envelope);
      }

      // Invoke PrePerspective lifecycle receptors (fires once per batch, not per event)
      if (events.Count > 0) {
        var firstEvent = events[0].Payload;  // Peek at first event for receptor routing

        var context = new LifecycleExecutionContext {
          CurrentStage = LifecycleStage.PrePerspectiveAsync,
          StreamId = streamId,
          PerspectiveType = typeof(__PERSPECTIVE_CLASS_NAME__),
          EventId = null,  // No specific event ID yet (haven't processed)
          LastProcessedEventId = lastProcessedEventId
        };

        // Fire ASYNC hooks (non-blocking - runs concurrently with perspective processing)
        // Note: We don't await this immediately, allowing it to run in parallel with perspective processing.
        // However, we track it to ensure completion before returning from RunAsync.
        var preAsyncTask = _lifecycleInvoker.InvokeAsync(
          firstEvent,  // Pass first event for type-based receptor routing
          LifecycleStage.PrePerspectiveAsync,
          context with { CurrentStage = LifecycleStage.PrePerspectiveAsync },
          cancellationToken
        ).AsTask();  // Convert ValueTask to Task for tracking
        backgroundTasks.Add(preAsyncTask);

        // Fire INLINE hooks (blocking, transactional)
        await _lifecycleInvoker.InvokeAsync(
          firstEvent,  // Pass first event for type-based receptor routing
          LifecycleStage.PrePerspectiveInline,
          context with { CurrentStage = LifecycleStage.PrePerspectiveInline },
          cancellationToken
        );
      }

      // Process all events in order
      foreach (var envelope in events) {

        // Extract event from envelope
        var @event = envelope.Payload;

        // Apply event to model using perspective's pure Apply method
        updatedModel = ApplyEvent(perspective, updatedModel, @event);

        // Track event for PostPerspective lifecycle hooks (fire AFTER save completes)
        processedEvents.Add((@event, envelope.MessageId.Value));

        // Track success
        lastSuccessfulEventId = envelope.MessageId.Value;
        eventsProcessed++;
      }

      // Unit of Work: Save model + checkpoint ONCE at end
      if (eventsProcessed > 0) {
        await SaveModelAndCheckpointAsync(
            streamId,
            updatedModel,
            lastSuccessfulEventId!.Value,
            cancellationToken
        );

        // CRITICAL: Explicitly flush all changes to ensure data is committed and queryable
        // PostgresUpsertStrategy.UpsertPerspectiveRowAsync() calls SaveChangesAsync() internally,
        // but we need to ensure the same DbContext is flushed before PostPerspectiveInline fires.
        // PostPerspectiveInline guarantees data is persisted and immediately queryable.
        await _perspectiveStore.FlushAsync(cancellationToken);

        _logger.LogInformation(
            "Successfully processed {EventCount} events for {PerspectiveName} stream {StreamId}, checkpoint: {CheckpointEventId}",
            eventsProcessed,
            perspectiveName,
            streamId,
            lastSuccessfulEventId
        );

        // Fire PostPerspectiveAsync lifecycle hooks AFTER perspective data is flushed
        // PostPerspectiveAsync is for early, non-blocking notification (data committed but checkpoint not yet saved)
        // PostPerspectiveInline fires LATER in PerspectiveWorker after checkpoint commits (guarantees both data + checkpoint are committed)
        foreach (var (evt, eventId) in processedEvents) {
          var context = new LifecycleExecutionContext {
            CurrentStage = LifecycleStage.PostPerspectiveAsync,
            StreamId = streamId,
            PerspectiveType = typeof(__PERSPECTIVE_CLASS_NAME__),
            EventId = eventId,
            LastProcessedEventId = lastSuccessfulEventId
          };

          // Fire ASYNC hooks (non-blocking - for early notification before checkpoint commits)
          // Note: We don't await this immediately, allowing perspective processing to complete.
          // However, we track it to ensure completion before returning from RunAsync.
          var postAsyncTask = _lifecycleInvoker.InvokeAsync(
            evt,
            LifecycleStage.PostPerspectiveAsync,
            context with { CurrentStage = LifecycleStage.PostPerspectiveAsync },
            cancellationToken
          ).AsTask();  // Convert ValueTask to Task for tracking
          backgroundTasks.Add(postAsyncTask);
        }
      }

      // CRITICAL: Wait for all background async lifecycle tasks to complete before returning
      // This ensures async stages (PrePerspectiveAsync, PostPerspectiveAsync) actually execute
      // even under thread pool exhaustion. Without this, Task.Run might not execute due to
      // thread pool saturation, causing lifecycle receptors to never fire.
      if (backgroundTasks.Count > 0) {
        await Task.WhenAll(backgroundTasks);
      }

      return new PerspectiveCheckpointCompletion {
        StreamId = streamId,
        PerspectiveName = perspectiveName,
        PerspectiveType = typeof(__PERSPECTIVE_CLASS_NAME__),
        LastEventId = lastSuccessfulEventId ?? lastProcessedEventId ?? Guid.Empty,
        Status = eventsProcessed > 0 ? PerspectiveProcessingStatus.Completed : PerspectiveProcessingStatus.None
      };

    } catch (Exception ex) {
      // Partial success: save checkpoint up to last successful event
      if (lastSuccessfulEventId != null && lastSuccessfulEventId != lastProcessedEventId) {
        _logger.LogWarning(
            ex,
            "Error processing events for {PerspectiveName} stream {StreamId} after {EventCount} events. Saving partial progress to checkpoint {CheckpointEventId}",
            perspectiveName,
            streamId,
            eventsProcessed,
            lastSuccessfulEventId
        );

        try {
          await SaveModelAndCheckpointAsync(
              streamId,
              updatedModel,
              lastSuccessfulEventId.Value,
              cancellationToken
          );
        } catch (Exception saveEx) {
          _logger.LogError(
              saveEx,
              "Failed to save partial progress for {PerspectiveName} stream {StreamId}",
              perspectiveName,
              streamId
          );
          // Re-throw - we couldn't save partial progress
          throw;
        }
      } else {
        _logger.LogError(
            ex,
            "Error processing first event for {PerspectiveName} stream {StreamId}, no progress to save",
            perspectiveName,
            streamId
        );
      }

      // Re-throw - let PerspectiveWorker catch and convert to failure
      throw;
    }
  }

  /// <summary>
  /// Creates an empty model for a new stream.
  /// Initializes the model with the stream ID set to the stream key property.
  /// </summary>
  private __MODEL_TYPE_NAME__ CreateEmptyModel(Guid streamId) {
    // Create instance using default constructor or Activator
    var model = System.Activator.CreateInstance<__MODEL_TYPE_NAME__>();

    // Set the stream key property
    var streamKeyProperty = typeof(__MODEL_TYPE_NAME__).GetProperty("__STREAM_KEY_PROPERTY__");
    if (streamKeyProperty != null && streamKeyProperty.CanWrite) {
      streamKeyProperty.SetValue(model, streamId);
    }

    return model;
  }

  /// <summary>
  /// Applies an event to the model using the perspective's synchronous Apply method.
  /// AOT-compatible: uses switch statement instead of reflection.
  /// Apply methods are pure functions that return new model state.
  /// </summary>
  private __MODEL_TYPE_NAME__ ApplyEvent(
      __PERSPECTIVE_CLASS_NAME__ perspective,
      __MODEL_TYPE_NAME__ currentModel,
      IEvent @event) {

    // AOT-compatible switch on event type (no reflection)
    // Generator produces one case per event type the perspective handles
    switch (@event) {
      #region EVENT_APPLY_CASES
      // Generated switch cases go here
      #endregion

      default:
        throw new InvalidOperationException(
            $"Perspective {perspective.GetType().Name} does not handle event type {@event.GetType().Name}"
        );
    }
  }

  #region EXTRACT_STREAM_ID_METHODS
  // Generated ExtractStreamId methods go here (one per event type)
  // These methods extract the stream ID from each event's [StreamKey] property
  #endregion

  /// <summary>
  /// Saves the model atomically.
  /// This is the ONLY place where database writes occur (unit of work pattern).
  /// Checkpoint persistence happens through the return value of RunAsync - the
  /// PerspectiveWorker collects checkpoint completions and reports them to
  /// ProcessWorkBatchAsync, which persists them via complete_perspective_checkpoint_work SQL function.
  /// </summary>
  private async Task SaveModelAndCheckpointAsync(
      Guid streamId,
      __MODEL_TYPE_NAME__ model,
      Guid checkpointEventId,
      CancellationToken cancellationToken) {

    // Upsert model (insert or update)
    // Checkpoint is persisted through RunAsync return value -> PerspectiveWorker -> ProcessWorkBatchAsync
    await _perspectiveStore.UpsertAsync(
        streamId,
        model,
        cancellationToken
    );
  }
}
