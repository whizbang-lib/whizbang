using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Whizbang.Generators;

/// <summary>
/// Incremental source generator that discovers IReceptor implementations
/// and generates dispatcher registration code.
/// </summary>
[Generator]
public class ReceptorDiscoveryGenerator : IIncrementalGenerator {
  private const string RECEPTOR_INTERFACE_NAME = "Whizbang.Core.IReceptor";

  public void Initialize(IncrementalGeneratorInitializationContext context) {
    // Filter for classes that have a base list (potential interface implementations)
    var receptorCandidates = context.SyntaxProvider.CreateSyntaxProvider(
        predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
        transform: static (ctx, ct) => ExtractReceptorInfo(ctx, ct)
    ).Where(static info => info is not null);

    // Collect all receptors and generate registration code
    context.RegisterSourceOutput(
        receptorCandidates.Collect(),
        static (ctx, receptors) => GenerateDispatcherRegistrations(ctx, receptors!)
    );
  }

  /// <summary>
  /// Extracts receptor information from a class declaration.
  /// Returns null if the class doesn't implement IReceptor.
  /// </summary>
  private static ReceptorInfo? ExtractReceptorInfo(
      GeneratorSyntaxContext context,
      System.Threading.CancellationToken cancellationToken) {

    var classDeclaration = (ClassDeclarationSyntax)context.Node;
    var semanticModel = context.SemanticModel;

    // Get the symbol for the class
    var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) as INamedTypeSymbol;
    if (classSymbol is null) {
      return null;
    }

    // Look for IReceptor<TMessage, TResponse> interface
    var receptorInterface = classSymbol.AllInterfaces.FirstOrDefault(i =>
        i.OriginalDefinition.ToDisplayString() == RECEPTOR_INTERFACE_NAME + "<TMessage, TResponse>");

    if (receptorInterface is null) {
      return null;
    }

    // Verify it has exactly 2 type arguments
    if (receptorInterface.TypeArguments.Length != 2) {
      // Can't report diagnostics here - will report in GenerateDispatcherRegistrations
      return null;
    }

    // Extract type information into value type (critical for performance)
    var info = new ReceptorInfo(
        ClassName: classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
        MessageType: receptorInterface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
        ResponseType: receptorInterface.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
    );

    return info;
  }

  /// <summary>
  /// Generates the dispatcher registration code for all discovered receptors.
  /// </summary>
  private static void GenerateDispatcherRegistrations(
      SourceProductionContext context,
      ImmutableArray<ReceptorInfo> receptors) {

    if (receptors.IsEmpty) {
      context.ReportDiagnostic(Diagnostic.Create(
          DiagnosticDescriptors.NoReceptorsFound,
          Location.None
      ));
      return;
    }

    // Report each discovered receptor
    foreach (var receptor in receptors) {
      context.ReportDiagnostic(Diagnostic.Create(
          DiagnosticDescriptors.ReceptorDiscovered,
          Location.None,
          GetSimpleName(receptor.ClassName),
          GetSimpleName(receptor.MessageType),
          GetSimpleName(receptor.ResponseType)
      ));
    }

    var registrationSource = GenerateRegistrationSource(receptors);
    context.AddSource("DispatcherRegistrations.g.cs", registrationSource);

    var diagnosticsSource = GenerateDiagnosticsSource(receptors);
    context.AddSource("ReceptorDiscoveryDiagnostics.g.cs", diagnosticsSource);
  }

  /// <summary>
  /// Generates the C# source code for the registration extension method.
  /// </summary>
  private static string GenerateRegistrationSource(ImmutableArray<ReceptorInfo> receptors) {
    var sb = new StringBuilder();

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
    sb.AppendLine();
    sb.AppendLine("namespace Whizbang.Core.Generated {");
    sb.AppendLine("    /// <summary>");
    sb.AppendLine("    /// Auto-generated dispatcher registrations for all discovered receptors.");
    sb.AppendLine("    /// </summary>");
    sb.AppendLine("    public static class DispatcherRegistrations {");
    sb.AppendLine("        /// <summary>");
    sb.AppendLine($"        /// Registers all {receptors.Length} discovered receptors with the service collection.");
    sb.AppendLine("        /// </summary>");
    sb.AppendLine("        public static IServiceCollection AddReceptors(this IServiceCollection services) {");

    foreach (var receptor in receptors) {
      sb.AppendLine($"            services.AddTransient<{RECEPTOR_INTERFACE_NAME}<{receptor.MessageType}, {receptor.ResponseType}>, {receptor.ClassName}>();");
    }

    sb.AppendLine("            return services;");
    sb.AppendLine("        }");
    sb.AppendLine("    }");
    sb.AppendLine("}");

    return sb.ToString();
  }

  /// <summary>
  /// Generates diagnostic registration code that adds receptor discovery
  /// information to the central WhizbangDiagnostics collection.
  /// </summary>
  private static string GenerateDiagnosticsSource(ImmutableArray<ReceptorInfo> receptors) {
    var sb = new StringBuilder();
    var buildTimestamp = System.DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC");

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("namespace Whizbang.Core.Generated {");
    sb.AppendLine("    /// <summary>");
    sb.AppendLine("    /// Registers receptor discovery diagnostics with the central diagnostics collector.");
    sb.AppendLine("    /// This class is auto-generated and registers its information during static initialization.");
    sb.AppendLine("    /// </summary>");
    sb.AppendLine("    public static class ReceptorDiscoveryDiagnostics {");
    sb.AppendLine("        static ReceptorDiscoveryDiagnostics() {");
    sb.AppendLine("            // Build a detailed message about discovered receptors");
    sb.AppendLine("            var message = new System.Text.StringBuilder();");
    sb.AppendLine($"            message.AppendLine(\"Discovered {receptors.Length} receptor(s):\");");

    for (int i = 0; i < receptors.Length; i++) {
      var receptor = receptors[i];
      sb.AppendLine($"            message.AppendLine(\"  [{i + 1}] {GetSimpleName(receptor.ClassName)}\");");
      sb.AppendLine($"            message.AppendLine(\"      Message:  {GetSimpleName(receptor.MessageType)}\");");
      sb.AppendLine($"            message.AppendLine(\"      Response: {GetSimpleName(receptor.ResponseType)}\");");
      if (i < receptors.Length - 1) {
        sb.AppendLine("            message.AppendLine();");
      }
    }

    sb.AppendLine();
    sb.AppendLine("            // Register this diagnostic entry");
    sb.AppendLine("            WhizbangDiagnostics.AddEntry(new DiagnosticEntry(");
    sb.AppendLine("                GeneratorName: \"ReceptorDiscoveryGenerator\",");
    sb.AppendLine($"                Timestamp: \"{buildTimestamp}\",");
    sb.AppendLine("                Category: DiagnosticCategory.ReceptorDiscovery,");
    sb.AppendLine("                Message: message.ToString()");
    sb.AppendLine("            ));");
    sb.AppendLine("        }");
    sb.AppendLine();
    sb.AppendLine("        /// <summary>");
    sb.AppendLine("        /// Forces static initialization of this class.");
    sb.AppendLine("        /// Call this method to ensure diagnostics are registered.");
    sb.AppendLine("        /// </summary>");
    sb.AppendLine("        public static void Register() {");
    sb.AppendLine("            // Method body intentionally empty.");
    sb.AppendLine("            // The static constructor does the real work.");
    sb.AppendLine("        }");
    sb.AppendLine("    }");
    sb.AppendLine("}");

    return sb.ToString();
  }

  /// <summary>
  /// Gets the simple name from a fully qualified type name.
  /// Handles tuples, arrays, and nested types.
  /// E.g., "global::MyApp.Commands.CreateOrder" -> "CreateOrder"
  /// E.g., "(global::A.B, global::C.D)" -> "(B, D)"
  /// E.g., "global::MyApp.Events.NotificationEvent[]" -> "NotificationEvent[]"
  /// </summary>
  private static string GetSimpleName(string fullyQualifiedName) {
    // Handle tuples: (Type1, Type2, ...)
    if (fullyQualifiedName.StartsWith("(") && fullyQualifiedName.EndsWith(")")) {
      var inner = fullyQualifiedName.Substring(1, fullyQualifiedName.Length - 2);
      var parts = SplitTupleParts(inner);
      var simplifiedParts = new string[parts.Length];
      for (int i = 0; i < parts.Length; i++) {
        simplifiedParts[i] = GetSimpleName(parts[i].Trim());
      }
      return "(" + string.Join(", ", simplifiedParts) + ")";
    }

    // Handle arrays: Type[]
    if (fullyQualifiedName.EndsWith("[]")) {
      var baseType = fullyQualifiedName.Substring(0, fullyQualifiedName.Length - 2);
      return GetSimpleName(baseType) + "[]";
    }

    // Handle simple types
    var lastDot = fullyQualifiedName.LastIndexOf('.');
    return lastDot >= 0 ? fullyQualifiedName.Substring(lastDot + 1) : fullyQualifiedName;
  }

  /// <summary>
  /// Splits tuple parts respecting nested tuples and parentheses.
  /// E.g., "A, B, (C, D)" -> ["A", "B", "(C, D)"]
  /// </summary>
  private static string[] SplitTupleParts(string tupleContent) {
    var parts = new System.Collections.Generic.List<string>();
    var currentPart = new System.Text.StringBuilder();
    var depth = 0;

    foreach (var ch in tupleContent) {
      if (ch == ',' && depth == 0) {
        parts.Add(currentPart.ToString());
        currentPart.Clear();
      } else {
        if (ch == '(') {
          depth++;
        } else if (ch == ')') {
          depth--;
        }

        currentPart.Append(ch);
      }
    }

    if (currentPart.Length > 0) {
      parts.Add(currentPart.ToString());
    }

    return parts.ToArray();
  }
}
