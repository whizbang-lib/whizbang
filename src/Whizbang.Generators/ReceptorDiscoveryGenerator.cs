using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Whizbang.Generators;

/// <summary>
/// Incremental source generator that discovers IReceptor implementations
/// and generates dispatcher registration code.
/// </summary>
[Generator]
public class ReceptorDiscoveryGenerator : IIncrementalGenerator {
  private const string RECEPTOR_INTERFACE_NAME = "Whizbang.Core.IReceptor";

  public void Initialize(IncrementalGeneratorInitializationContext context) {
    // Filter for classes that have a base list (potential interface implementations)
    var receptorCandidates = context.SyntaxProvider.CreateSyntaxProvider(
        predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
        transform: static (ctx, ct) => ExtractReceptorInfo(ctx, ct)
    ).Where(static info => info is not null);

    // Collect all receptors and generate registration code
    context.RegisterSourceOutput(
        receptorCandidates.Collect(),
        static (ctx, receptors) => GenerateDispatcherRegistrations(ctx, receptors!)
    );
  }

  /// <summary>
  /// Extracts receptor information from a class declaration.
  /// Returns null if the class doesn't implement IReceptor.
  /// </summary>
  private static ReceptorInfo? ExtractReceptorInfo(
      GeneratorSyntaxContext context,
      System.Threading.CancellationToken cancellationToken) {

    var classDeclaration = (ClassDeclarationSyntax)context.Node;
    var semanticModel = context.SemanticModel;

    // Get the symbol for the class
    var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) as INamedTypeSymbol;
    if (classSymbol is null) {
      return null;
    }

    // Look for IReceptor<TMessage, TResponse> interface
    var receptorInterface = classSymbol.AllInterfaces.FirstOrDefault(i =>
        i.OriginalDefinition.ToDisplayString() == RECEPTOR_INTERFACE_NAME + "<TMessage, TResponse>");

    if (receptorInterface is null) {
      return null;
    }

    // Verify it has exactly 2 type arguments
    if (receptorInterface.TypeArguments.Length != 2) {
      // Can't report diagnostics here - will report in GenerateDispatcherRegistrations
      return null;
    }

    // Extract type information into value type (critical for performance)
    var info = new ReceptorInfo(
        ClassName: classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
        MessageType: receptorInterface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
        ResponseType: receptorInterface.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
    );

    return info;
  }

  /// <summary>
  /// Generates the dispatcher registration code for all discovered receptors.
  /// </summary>
  private static void GenerateDispatcherRegistrations(
      SourceProductionContext context,
      ImmutableArray<ReceptorInfo> receptors) {

    if (receptors.IsEmpty) {
      context.ReportDiagnostic(Diagnostic.Create(
          DiagnosticDescriptors.NoReceptorsFound,
          Location.None
      ));
      return;
    }

    // Report each discovered receptor
    foreach (var receptor in receptors) {
      context.ReportDiagnostic(Diagnostic.Create(
          DiagnosticDescriptors.ReceptorDiscovered,
          Location.None,
          GetSimpleName(receptor.ClassName),
          GetSimpleName(receptor.MessageType),
          GetSimpleName(receptor.ResponseType)
      ));
    }

    var source = GenerateRegistrationSource(receptors);
    context.AddSource("DispatcherRegistrations.g.cs", source);
  }

  /// <summary>
  /// Generates the C# source code for the registration extension method.
  /// </summary>
  private static string GenerateRegistrationSource(ImmutableArray<ReceptorInfo> receptors) {
    var sb = new StringBuilder();

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
    sb.AppendLine();
    sb.AppendLine("namespace Whizbang.Core.Generated {");
    sb.AppendLine("    /// <summary>");
    sb.AppendLine("    /// Auto-generated dispatcher registrations for all discovered receptors.");
    sb.AppendLine("    /// </summary>");
    sb.AppendLine("    public static class DispatcherRegistrations {");
    sb.AppendLine("        /// <summary>");
    sb.AppendLine($"        /// Registers all {receptors.Length} discovered receptors with the service collection.");
    sb.AppendLine("        /// </summary>");
    sb.AppendLine("        public static IServiceCollection AddReceptors(this IServiceCollection services) {");

    foreach (var receptor in receptors) {
      sb.AppendLine($"            services.AddTransient<{RECEPTOR_INTERFACE_NAME}<{receptor.MessageType}, {receptor.ResponseType}>, {receptor.ClassName}>();");
    }

    sb.AppendLine("            return services;");
    sb.AppendLine("        }");
    sb.AppendLine("    }");
    sb.AppendLine("}");

    return sb.ToString();
  }

  /// <summary>
  /// Gets the simple name from a fully qualified type name.
  /// E.g., "global::MyApp.Commands.CreateOrder" -> "CreateOrder"
  /// </summary>
  private static string GetSimpleName(string fullyQualifiedName) {
    var lastDot = fullyQualifiedName.LastIndexOf('.');
    return lastDot >= 0 ? fullyQualifiedName.Substring(lastDot + 1) : fullyQualifiedName;
  }
}
